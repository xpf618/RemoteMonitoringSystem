; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_mutex.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_mutex.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -IH:\½øÐÐÊ±\CS_System_Program\Project\MDK-ARM(uV4)\RTE -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\os_mutex.crf ..\..\uCOS-III\uCOS-III\Source\os_mutex.c]
                          THUMB

                          AREA ||i.OSMutexCreate||, CODE, READONLY, ALIGN=2

                  OSMutexCreate PROC
;;;68     
;;;69     void  OSMutexCreate (OS_MUTEX  *p_mutex,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70                          CPU_CHAR  *p_name,
;;;71                          OS_ERR    *p_err)
;;;72     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;73         CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;74     
;;;75     
;;;76     
;;;77     #ifdef OS_SAFETY_CRITICAL
;;;78         if (p_err == DEF_NULL) {
;;;79             OS_SAFETY_CRITICAL_EXCEPTION();
;;;80             return;
;;;81         }
;;;82     #endif
;;;83     
;;;84     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;85         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;86            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;87             return;
;;;88         }
;;;89     #endif
;;;90     
;;;91     #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;92         if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
00000c  481b              LDR      r0,|L1.124|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  b120              CBZ      r0,|L1.28|
;;;93            *p_err = OS_ERR_CREATE_ISR;
000012  f64260e1          MOV      r0,#0x2ee1
000016  8028              STRH     r0,[r5,#0]
                  |L1.24|
;;;94             return;
;;;95         }
;;;96     #endif
;;;97     
;;;98     #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;99         if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
;;;100           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;101            return;
;;;102        }
;;;103    #endif
;;;104    
;;;105        OS_CRITICAL_ENTER();
;;;106    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;107        p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;            /* Mark the data structure as a mutex                   */
;;;108    #endif
;;;109    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;110        p_mutex->NamePtr           =  p_name;
;;;111    #else
;;;112        (void)&p_name;
;;;113    #endif
;;;114        p_mutex->MutexGrpNextPtr   = DEF_NULL;
;;;115        p_mutex->OwnerTCBPtr       = DEF_NULL;
;;;116        p_mutex->OwnerNestingCtr   = 0u;                            /* Mutex is available                                   */
;;;117    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;118        p_mutex->TS                = 0u;
;;;119    #endif
;;;120        OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
;;;121    
;;;122    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;123        OS_MutexDbgListAdd(p_mutex);
;;;124        OSMutexQty++;
;;;125    #endif
;;;126    
;;;127    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;128        TRACE_OS_MUTEX_CREATE(p_mutex, p_name);                     /* Record the event.                                    */
;;;129    #endif
;;;130    
;;;131        OS_CRITICAL_EXIT_NO_SCHED();
;;;132       *p_err = OS_ERR_NONE;
;;;133    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  b91c              CBNZ     r4,|L1.38|
00001e  f64550c3          MOV      r0,#0x5dc3            ;100
000022  8028              STRH     r0,[r5,#0]            ;100
000024  e7f8              B        |L1.24|
                  |L1.38|
000026  bf00              NOP                            ;105
000028  bf00              NOP                            ;105
00002a  f7fffffe          BL       CPU_SR_Save
00002e  4607              MOV      r7,r0                 ;105
000030  bf00              NOP                            ;105
000032  f7fffffe          BL       CPU_IntDisMeasStart
000036  bf00              NOP                            ;105
000038  4811              LDR      r0,|L1.128|
00003a  6020              STR      r0,[r4,#0]            ;107
00003c  6066              STR      r6,[r4,#4]            ;110
00003e  2000              MOVS     r0,#0                 ;114
000040  6220              STR      r0,[r4,#0x20]         ;114
000042  6260              STR      r0,[r4,#0x24]         ;115
000044  f8840028          STRB     r0,[r4,#0x28]         ;116
000048  62e0              STR      r0,[r4,#0x2c]         ;118
00004a  f1040008          ADD      r0,r4,#8              ;120
00004e  f7fffffe          BL       OS_PendListInit
000052  4620              MOV      r0,r4                 ;123
000054  f7fffffe          BL       OS_MutexDbgListAdd
000058  480a              LDR      r0,|L1.132|
00005a  8800              LDRH     r0,[r0,#0]            ;124  ; OSMutexQty
00005c  1c40              ADDS     r0,r0,#1              ;124
00005e  4909              LDR      r1,|L1.132|
000060  8008              STRH     r0,[r1,#0]            ;124
000062  bf00              NOP                            ;131
000064  f7fffffe          BL       CPU_IntDisMeasStop
000068  bf00              NOP                            ;131
00006a  4638              MOV      r0,r7                 ;131
00006c  f7fffffe          BL       CPU_SR_Restore
000070  bf00              NOP                            ;131
000072  bf00              NOP                            ;131
000074  2000              MOVS     r0,#0                 ;132
000076  8028              STRH     r0,[r5,#0]            ;132
000078  bf00              NOP      
00007a  e7cd              B        |L1.24|
;;;134    
                          ENDP

                  |L1.124|
                          DCD      OSIntNestingCtr
                  |L1.128|
                          DCD      0x5854554d
                  |L1.132|
                          DCD      OSMutexQty

                          AREA ||i.OSMutexPend||, CODE, READONLY, ALIGN=2

                  OSMutexPend PROC
;;;359    
;;;360    void  OSMutexPend (OS_MUTEX  *p_mutex,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;361                       OS_TICK    timeout,
;;;362                       OS_OPT     opt,
;;;363                       CPU_TS    *p_ts,
;;;364                       OS_ERR    *p_err)
;;;365    {
000004  b088              SUB      sp,sp,#0x20
000006  4605              MOV      r5,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  461c              MOV      r4,r3
00000e  9e10              LDR      r6,[sp,#0x40]
;;;366        OS_PEND_DATA  pend_data;
;;;367        OS_TCB       *p_tcb;
;;;368        CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;369    
;;;370    
;;;371    #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;372        (void)&p_ts;                                                /* Prevent compiler warning for not using 'ts'          */
;;;373    #endif
;;;374    
;;;375    #ifdef OS_SAFETY_CRITICAL
;;;376        if (p_err == DEF_NULL) {
;;;377            OS_SAFETY_CRITICAL_EXCEPTION();
;;;378            return;
;;;379        }
;;;380    #endif
;;;381    
;;;382    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;383        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000014  4880              LDR      r0,|L2.536|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000018  b128              CBZ      r0,|L2.38|
;;;384    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;385            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;386    #endif
;;;387           *p_err = OS_ERR_PEND_ISR;
00001a  f24610ae          MOV      r0,#0x61ae
00001e  8030              STRH     r0,[r6,#0]
                  |L2.32|
;;;388            return;
;;;389        }
;;;390    #endif
;;;391    
;;;392    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;393        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;394           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;395            return;
;;;396        }
;;;397    #endif
;;;398    
;;;399    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;400        if (p_mutex == DEF_NULL) {                                  /* Validate arguments                                   */
;;;401    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;402            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;403    #endif
;;;404           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;405            return;
;;;406        }
;;;407        switch (opt) {                                              /* Validate 'opt'                                       */
;;;408            case OS_OPT_PEND_BLOCKING:
;;;409            case OS_OPT_PEND_NON_BLOCKING:
;;;410                 break;
;;;411    
;;;412            default:
;;;413    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;414                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;415    #endif
;;;416                *p_err = OS_ERR_OPT_INVALID;
;;;417                 return;
;;;418        }
;;;419    #endif
;;;420    
;;;421    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;422        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
;;;423    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;424            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;425    #endif
;;;426           *p_err = OS_ERR_OBJ_TYPE;
;;;427            return;
;;;428        }
;;;429    #endif
;;;430    
;;;431        CPU_CRITICAL_ENTER();
;;;432        if (p_mutex->OwnerNestingCtr == 0u) {                       /* Resource available?                                  */
;;;433            p_mutex->OwnerTCBPtr     = OSTCBCurPtr;                 /* Yes, caller may proceed                              */
;;;434            p_mutex->OwnerNestingCtr = 1u;
;;;435    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;436            if (p_ts != DEF_NULL) {
;;;437               *p_ts = p_mutex->TS;
;;;438            }
;;;439    #endif
;;;440            OS_MutexGrpAdd(OSTCBCurPtr, p_mutex);                   /* Add mutex to owner's group                           */
;;;441            CPU_CRITICAL_EXIT();
;;;442    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;443            TRACE_OS_MUTEX_PEND(p_mutex);                           /* Record the event.                                    */
;;;444    #endif
;;;445           *p_err = OS_ERR_NONE;
;;;446            return;
;;;447        }
;;;448    
;;;449        if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {                  /* See if current task is already the owner of the mutex*/
;;;450            if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)-1) {
;;;451                CPU_CRITICAL_EXIT();
;;;452    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;453                TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                    */
;;;454    #endif
;;;455               *p_err = OS_ERR_MUTEX_OVF;
;;;456                return;
;;;457            }
;;;458            p_mutex->OwnerNestingCtr++;
;;;459    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;460            if (p_ts != DEF_NULL) {
;;;461               *p_ts = p_mutex->TS;
;;;462            }
;;;463    #endif
;;;464            CPU_CRITICAL_EXIT();
;;;465    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;466            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;467    #endif
;;;468           *p_err = OS_ERR_MUTEX_OWNER;                             /* Indicate that current task already owns the mutex    */
;;;469            return;
;;;470        }
;;;471    
;;;472        if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
;;;473            CPU_CRITICAL_EXIT();
;;;474    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;475            if (p_ts != DEF_NULL) {
;;;476               *p_ts = 0u;
;;;477            }
;;;478    #endif
;;;479    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;480            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;481    #endif
;;;482           *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
;;;483            return;
;;;484        } else {
;;;485            if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
;;;486                CPU_CRITICAL_EXIT();
;;;487    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;488                if (p_ts != DEF_NULL) {
;;;489                   *p_ts = 0u;
;;;490                }
;;;491    #endif
;;;492    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;493                TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                    */
;;;494    #endif
;;;495               *p_err = OS_ERR_SCHED_LOCKED;
;;;496                return;
;;;497            }
;;;498        }
;;;499                                                                    /* Lock the scheduler/re-enable interrupts              */
;;;500        OS_CRITICAL_ENTER_CPU_EXIT();
;;;501        p_tcb = p_mutex->OwnerTCBPtr;                               /* Point to the TCB of the Mutex owner                  */
;;;502        if (p_tcb->Prio > OSTCBCurPtr->Prio) {                      /* See if mutex owner has a lower priority than current */
;;;503            OS_TaskChangePrio(p_tcb, OSTCBCurPtr->Prio);
;;;504    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;505                     TRACE_OS_MUTEX_TASK_PRIO_INHERIT(p_tcb, p_tcb->Prio);
;;;506    #endif
;;;507        }
;;;508    
;;;509        OS_Pend(&pend_data,                                         /* Block task pending on Mutex                          */
;;;510                (OS_PEND_OBJ *)((void *)p_mutex),
;;;511                 OS_TASK_PEND_ON_MUTEX,
;;;512                 timeout);
;;;513    
;;;514        OS_CRITICAL_EXIT_NO_SCHED();
;;;515    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;516        TRACE_OS_MUTEX_PEND_BLOCK(p_mutex);                         /* Record the event.                                    */
;;;517    #endif
;;;518        OSSched();                                                  /* Find the next highest priority task ready to run     */
;;;519    
;;;520        CPU_CRITICAL_ENTER();
;;;521        switch (OSTCBCurPtr->PendStatus) {
;;;522            case OS_STATUS_PEND_OK:                                 /* We got the mutex                                     */
;;;523    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;524                 if (p_ts != DEF_NULL) {
;;;525                    *p_ts = OSTCBCurPtr->TS;
;;;526                 }
;;;527    #endif
;;;528    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;529                 TRACE_OS_MUTEX_PEND(p_mutex);                      /* Record the event.                                    */
;;;530    #endif
;;;531                *p_err = OS_ERR_NONE;
;;;532                 break;
;;;533    
;;;534            case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
;;;535    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;536                 if (p_ts != DEF_NULL) {
;;;537                    *p_ts = OSTCBCurPtr->TS;
;;;538                 }
;;;539    #endif
;;;540    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;541                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;542    #endif
;;;543                *p_err = OS_ERR_PEND_ABORT;
;;;544                 break;
;;;545    
;;;546            case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get mutex within timeout     */
;;;547    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;548                 if (p_ts != DEF_NULL) {
;;;549                    *p_ts = 0u;
;;;550                 }
;;;551    #endif
;;;552    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;553                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;554    #endif
;;;555                *p_err = OS_ERR_TIMEOUT;
;;;556                 break;
;;;557    
;;;558            case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
;;;559    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;560                 if (p_ts != DEF_NULL) {
;;;561                    *p_ts = OSTCBCurPtr->TS;
;;;562                 }
;;;563    #endif
;;;564    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;565                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;566    #endif
;;;567                *p_err = OS_ERR_OBJ_DEL;
;;;568                 break;
;;;569    
;;;570            default:
;;;571    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;572                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;573    #endif
;;;574                *p_err = OS_ERR_STATUS_INVALID;
;;;575                 break;
;;;576        }
;;;577        CPU_CRITICAL_EXIT();
;;;578    }
000020  b008              ADD      sp,sp,#0x20
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L2.38|
000026  b91d              CBNZ     r5,|L2.48|
000028  f64550c3          MOV      r0,#0x5dc3            ;404
00002c  8030              STRH     r0,[r6,#0]            ;404
00002e  e7f7              B        |L2.32|
                  |L2.48|
000030  b11f              CBZ      r7,|L2.58|
000032  f5b74f00          CMP      r7,#0x8000            ;407
000036  d102              BNE      |L2.62|
000038  e000              B        |L2.60|
                  |L2.58|
00003a  bf00              NOP                            ;409
                  |L2.60|
00003c  e003              B        |L2.70|
                  |L2.62|
00003e  f6456025          MOV      r0,#0x5e25            ;416
000042  8030              STRH     r0,[r6,#0]            ;416
000044  e7ec              B        |L2.32|
                  |L2.70|
000046  bf00              NOP                            ;410
000048  4974              LDR      r1,|L2.540|
00004a  6828              LDR      r0,[r5,#0]            ;422
00004c  4288              CMP      r0,r1                 ;422
00004e  d003              BEQ      |L2.88|
000050  f64550c4          MOV      r0,#0x5dc4            ;426
000054  8030              STRH     r0,[r6,#0]            ;426
000056  e7e3              B        |L2.32|
                  |L2.88|
000058  bf00              NOP                            ;431
00005a  bf00              NOP                            ;431
00005c  f7fffffe          BL       CPU_SR_Save
000060  4682              MOV      r10,r0                ;431
000062  bf00              NOP                            ;431
000064  f7fffffe          BL       CPU_IntDisMeasStart
000068  bf00              NOP                            ;431
00006a  f8950028          LDRB     r0,[r5,#0x28]         ;432
00006e  b9c8              CBNZ     r0,|L2.164|
000070  486b              LDR      r0,|L2.544|
000072  6800              LDR      r0,[r0,#0]            ;433  ; OSTCBCurPtr
000074  6268              STR      r0,[r5,#0x24]         ;433
000076  2001              MOVS     r0,#1                 ;434
000078  f8850028          STRB     r0,[r5,#0x28]         ;434
00007c  b10c              CBZ      r4,|L2.130|
00007e  6ae8              LDR      r0,[r5,#0x2c]         ;437
000080  6020              STR      r0,[r4,#0]            ;437
                  |L2.130|
000082  4629              MOV      r1,r5                 ;440
000084  4866              LDR      r0,|L2.544|
000086  6800              LDR      r0,[r0,#0]            ;440  ; OSTCBCurPtr
000088  f7fffffe          BL       OS_MutexGrpAdd
00008c  bf00              NOP                            ;441
00008e  f7fffffe          BL       CPU_IntDisMeasStop
000092  bf00              NOP                            ;441
000094  4650              MOV      r0,r10                ;441
000096  f7fffffe          BL       CPU_SR_Restore
00009a  bf00              NOP                            ;441
00009c  bf00              NOP                            ;441
00009e  2000              MOVS     r0,#0                 ;445
0000a0  8030              STRH     r0,[r6,#0]            ;445
0000a2  e7bd              B        |L2.32|
                  |L2.164|
0000a4  495e              LDR      r1,|L2.544|
0000a6  6a68              LDR      r0,[r5,#0x24]         ;449
0000a8  6809              LDR      r1,[r1,#0]            ;449  ; OSTCBCurPtr
0000aa  4288              CMP      r0,r1                 ;449
0000ac  d125              BNE      |L2.250|
0000ae  f8950028          LDRB     r0,[r5,#0x28]         ;450
0000b2  28ff              CMP      r0,#0xff              ;450
0000b4  d10c              BNE      |L2.208|
0000b6  bf00              NOP                            ;451
0000b8  f7fffffe          BL       CPU_IntDisMeasStop
0000bc  bf00              NOP                            ;451
0000be  4650              MOV      r0,r10                ;451
0000c0  f7fffffe          BL       CPU_SR_Restore
0000c4  bf00              NOP                            ;451
0000c6  bf00              NOP                            ;451
0000c8  f2457084          MOV      r0,#0x5784            ;455
0000cc  8030              STRH     r0,[r6,#0]            ;455
0000ce  e7a7              B        |L2.32|
                  |L2.208|
0000d0  f8950028          LDRB     r0,[r5,#0x28]         ;458
0000d4  1c40              ADDS     r0,r0,#1              ;458
0000d6  f8850028          STRB     r0,[r5,#0x28]         ;458
0000da  b10c              CBZ      r4,|L2.224|
0000dc  6ae8              LDR      r0,[r5,#0x2c]         ;461
0000de  6020              STR      r0,[r4,#0]            ;461
                  |L2.224|
0000e0  bf00              NOP                            ;464
0000e2  f7fffffe          BL       CPU_IntDisMeasStop
0000e6  bf00              NOP                            ;464
0000e8  4650              MOV      r0,r10                ;464
0000ea  f7fffffe          BL       CPU_SR_Restore
0000ee  bf00              NOP                            ;464
0000f0  bf00              NOP                            ;464
0000f2  f2457082          MOV      r0,#0x5782            ;468
0000f6  8030              STRH     r0,[r6,#0]            ;468
0000f8  e792              B        |L2.32|
                  |L2.250|
0000fa  f4074000          AND      r0,r7,#0x8000         ;472
0000fe  b178              CBZ      r0,|L2.288|
000100  bf00              NOP                            ;473
000102  f7fffffe          BL       CPU_IntDisMeasStop
000106  bf00              NOP                            ;473
000108  4650              MOV      r0,r10                ;473
00010a  f7fffffe          BL       CPU_SR_Restore
00010e  bf00              NOP                            ;473
000110  bf00              NOP                            ;473
000112  b10c              CBZ      r4,|L2.280|
000114  2000              MOVS     r0,#0                 ;476
000116  6020              STR      r0,[r4,#0]            ;476
                  |L2.280|
000118  f24610b0          MOV      r0,#0x61b0            ;482
00011c  8030              STRH     r0,[r6,#0]            ;482
00011e  e77f              B        |L2.32|
                  |L2.288|
000120  4840              LDR      r0,|L2.548|
000122  7800              LDRB     r0,[r0,#0]            ;485  ; OSSchedLockNestingCtr
000124  b178              CBZ      r0,|L2.326|
000126  bf00              NOP                            ;486
000128  f7fffffe          BL       CPU_IntDisMeasStop
00012c  bf00              NOP                            ;486
00012e  4650              MOV      r0,r10                ;486
000130  f7fffffe          BL       CPU_SR_Restore
000134  bf00              NOP                            ;486
000136  bf00              NOP                            ;486
000138  b10c              CBZ      r4,|L2.318|
00013a  2000              MOVS     r0,#0                 ;489
00013c  6020              STR      r0,[r4,#0]            ;489
                  |L2.318|
00013e  f6465063          MOV      r0,#0x6d63            ;495
000142  8030              STRH     r0,[r6,#0]            ;495
000144  e76c              B        |L2.32|
                  |L2.326|
000146  f8d58024          LDR      r8,[r5,#0x24]         ;501
00014a  f8980037          LDRB     r0,[r8,#0x37]         ;502
00014e  4934              LDR      r1,|L2.544|
000150  6809              LDR      r1,[r1,#0]            ;502  ; OSTCBCurPtr
000152  f8911037          LDRB     r1,[r1,#0x37]         ;502
000156  4288              CMP      r0,r1                 ;502
000158  dd06              BLE      |L2.360|
00015a  4831              LDR      r0,|L2.544|
00015c  6800              LDR      r0,[r0,#0]            ;503  ; OSTCBCurPtr
00015e  f8901037          LDRB     r1,[r0,#0x37]         ;503
000162  4640              MOV      r0,r8                 ;503
000164  f7fffffe          BL       OS_TaskChangePrio
                  |L2.360|
000168  464b              MOV      r3,r9                 ;509
00016a  2204              MOVS     r2,#4                 ;509
00016c  4629              MOV      r1,r5                 ;509
00016e  4668              MOV      r0,sp                 ;509
000170  f7fffffe          BL       OS_Pend
000174  bf00              NOP                            ;514
000176  f7fffffe          BL       CPU_IntDisMeasStop
00017a  bf00              NOP                            ;514
00017c  4650              MOV      r0,r10                ;514
00017e  f7fffffe          BL       CPU_SR_Restore
000182  bf00              NOP                            ;514
000184  bf00              NOP                            ;514
000186  f7fffffe          BL       OSSched
00018a  bf00              NOP                            ;520
00018c  bf00              NOP                            ;520
00018e  f7fffffe          BL       CPU_SR_Save
000192  4682              MOV      r10,r0                ;520
000194  bf00              NOP                            ;520
000196  f7fffffe          BL       CPU_IntDisMeasStart
00019a  bf00              NOP                            ;520
00019c  4820              LDR      r0,|L2.544|
00019e  6800              LDR      r0,[r0,#0]            ;521  ; OSTCBCurPtr
0001a0  f8900035          LDRB     r0,[r0,#0x35]         ;521
0001a4  b130              CBZ      r0,|L2.436|
0001a6  2801              CMP      r0,#1                 ;521
0001a8  d00c              BEQ      |L2.452|
0001aa  2802              CMP      r0,#2                 ;521
0001ac  d01a              BEQ      |L2.484|
0001ae  2803              CMP      r0,#3                 ;521
0001b0  d121              BNE      |L2.502|
0001b2  e010              B        |L2.470|
                  |L2.436|
0001b4  b11c              CBZ      r4,|L2.446|
0001b6  481a              LDR      r0,|L2.544|
0001b8  6800              LDR      r0,[r0,#0]            ;525  ; OSTCBCurPtr
0001ba  6c80              LDR      r0,[r0,#0x48]         ;525
0001bc  6020              STR      r0,[r4,#0]            ;525
                  |L2.446|
0001be  2000              MOVS     r0,#0                 ;531
0001c0  8030              STRH     r0,[r6,#0]            ;531
0001c2  e01c              B        |L2.510|
                  |L2.452|
0001c4  b11c              CBZ      r4,|L2.462|
0001c6  4816              LDR      r0,|L2.544|
0001c8  6800              LDR      r0,[r0,#0]            ;537  ; OSTCBCurPtr
0001ca  6c80              LDR      r0,[r0,#0x48]         ;537
0001cc  6020              STR      r0,[r4,#0]            ;537
                  |L2.462|
0001ce  f24610a9          MOV      r0,#0x61a9            ;543
0001d2  8030              STRH     r0,[r6,#0]            ;543
0001d4  e013              B        |L2.510|
                  |L2.470|
0001d6  b10c              CBZ      r4,|L2.476|
0001d8  2000              MOVS     r0,#0                 ;549
0001da  6020              STR      r0,[r4,#0]            ;549
                  |L2.476|
0001dc  f24720d9          MOV      r0,#0x72d9            ;555
0001e0  8030              STRH     r0,[r6,#0]            ;555
0001e2  e00c              B        |L2.510|
                  |L2.484|
0001e4  b11c              CBZ      r4,|L2.494|
0001e6  480e              LDR      r0,|L2.544|
0001e8  6800              LDR      r0,[r0,#0]            ;561  ; OSTCBCurPtr
0001ea  6c80              LDR      r0,[r0,#0x48]         ;561
0001ec  6020              STR      r0,[r4,#0]            ;561
                  |L2.494|
0001ee  f64550c2          MOV      r0,#0x5dc2            ;567
0001f2  8030              STRH     r0,[r6,#0]            ;567
0001f4  e003              B        |L2.510|
                  |L2.502|
0001f6  f646602e          MOV      r0,#0x6e2e            ;574
0001fa  8030              STRH     r0,[r6,#0]            ;574
0001fc  bf00              NOP                            ;575
                  |L2.510|
0001fe  bf00              NOP                            ;532
000200  bf00              NOP                            ;577
000202  f7fffffe          BL       CPU_IntDisMeasStop
000206  bf00              NOP                            ;577
000208  4650              MOV      r0,r10                ;577
00020a  f7fffffe          BL       CPU_SR_Restore
00020e  bf00              NOP                            ;577
000210  bf00              NOP                            ;577
000212  bf00              NOP      
000214  e704              B        |L2.32|
;;;579    
                          ENDP

000216  0000              DCW      0x0000
                  |L2.536|
                          DCD      OSIntNestingCtr
                  |L2.540|
                          DCD      0x5854554d
                  |L2.544|
                          DCD      OSTCBCurPtr
                  |L2.548|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSMutexPost||, CODE, READONLY, ALIGN=2

                  OSMutexPost PROC
;;;759    
;;;760    void  OSMutexPost (OS_MUTEX  *p_mutex,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;761                       OS_OPT     opt,
;;;762                       OS_ERR    *p_err)
;;;763    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;764        OS_PEND_LIST  *p_pend_list;
;;;765        OS_TCB        *p_tcb;
;;;766        CPU_TS         ts;
;;;767        OS_PRIO        prio_new;
;;;768        CPU_SR_ALLOC();
00000a  f04f0b00          MOV      r11,#0
;;;769    
;;;770    
;;;771    #ifdef OS_SAFETY_CRITICAL
;;;772        if (p_err == DEF_NULL) {
;;;773            OS_SAFETY_CRITICAL_EXCEPTION();
;;;774            return;
;;;775        }
;;;776    #endif
;;;777    
;;;778    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;779        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
00000e  4864              LDR      r0,|L3.416|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  b120              CBZ      r0,|L3.30|
;;;780    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;781            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;782    #endif
;;;783           *p_err = OS_ERR_POST_ISR;
000014  f246200e          MOV      r0,#0x620e
000018  8028              STRH     r0,[r5,#0]
                  |L3.26|
;;;784            return;
;;;785        }
;;;786    #endif
;;;787    
;;;788    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;789        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;790           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;791            return;
;;;792        }
;;;793    #endif
;;;794    
;;;795    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;796        if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
;;;797    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;798            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;799    #endif
;;;800           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;801            return;
;;;802        }
;;;803        switch (opt) {                                              /* Validate 'opt'                                       */
;;;804            case OS_OPT_POST_NONE:
;;;805            case OS_OPT_POST_NO_SCHED:
;;;806                 break;
;;;807    
;;;808            default:
;;;809    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;810                 TRACE_OS_MUTEX_POST_FAILED(p_mutex);               /* Record the event.                                    */
;;;811    #endif
;;;812                *p_err =  OS_ERR_OPT_INVALID;
;;;813                 return;
;;;814        }
;;;815    #endif
;;;816    
;;;817    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;818        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
;;;819    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;820            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;821    #endif
;;;822           *p_err = OS_ERR_OBJ_TYPE;
;;;823            return;
;;;824        }
;;;825    #endif
;;;826    
;;;827        CPU_CRITICAL_ENTER();
;;;828        if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {                  /* Make sure the mutex owner is releasing the mutex     */
;;;829            CPU_CRITICAL_EXIT();
;;;830    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;831            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;832    #endif
;;;833           *p_err = OS_ERR_MUTEX_NOT_OWNER;
;;;834            return;
;;;835        }
;;;836    
;;;837    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;838        TRACE_OS_MUTEX_POST(p_mutex);                               /* Record the event.                                    */
;;;839    #endif
;;;840    
;;;841        OS_CRITICAL_ENTER_CPU_EXIT();
;;;842    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;843        ts          = OS_TS_GET();                                  /* Get timestamp                                        */
;;;844        p_mutex->TS = ts;
;;;845    #else
;;;846        ts          = 0u;
;;;847    #endif
;;;848        p_mutex->OwnerNestingCtr--;                                 /* Decrement owner's nesting counter                    */
;;;849        if (p_mutex->OwnerNestingCtr > 0u) {                        /* Are we done with all nestings?                       */
;;;850            OS_CRITICAL_EXIT();                                     /* No                                                   */
;;;851           *p_err = OS_ERR_MUTEX_NESTING;
;;;852            return;
;;;853        }
;;;854    
;;;855        OS_MutexGrpRemove(OSTCBCurPtr, p_mutex);                    /* Remove mutex from owner's group                      */
;;;856    
;;;857        p_pend_list = &p_mutex->PendList;
;;;858        if (p_pend_list->HeadPtr == DEF_NULL) {                      /* Any task waiting on mutex?                           */
;;;859            p_mutex->OwnerTCBPtr     = DEF_NULL;                    /* No                                                   */
;;;860            p_mutex->OwnerNestingCtr = 0u;
;;;861            OS_CRITICAL_EXIT();
;;;862           *p_err = OS_ERR_NONE;
;;;863            return;
;;;864        }
;;;865                                                                    /* Yes                                                  */
;;;866        if (OSTCBCurPtr->Prio != OSTCBCurPtr->BasePrio) {           /* Has owner inherited a priority?                      */
;;;867            prio_new = OS_MutexGrpPrioFindHighest(OSTCBCurPtr);     /* Yes, find highest priority pending                   */
;;;868            prio_new = prio_new > OSTCBCurPtr->BasePrio ? OSTCBCurPtr->BasePrio : prio_new;
;;;869            if (prio_new > OSTCBCurPtr->Prio) {
;;;870                OS_RdyListRemove(OSTCBCurPtr);
;;;871                OSTCBCurPtr->Prio = prio_new;                       /* Lower owner's priority back to its original one      */
;;;872    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;873                TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(OSTCBCurPtr, prio_new);
;;;874    #endif
;;;875                OS_PrioInsert(prio_new);
;;;876                OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority           */
;;;877                OSPrioCur         = prio_new;
;;;878            }
;;;879        }
;;;880                                                                    /* Get TCB from head of pend list                       */
;;;881        p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
;;;882        p_mutex->OwnerTCBPtr       = p_tcb;                         /* Give mutex to new owner                              */
;;;883        p_mutex->OwnerNestingCtr   = 1u;
;;;884        OS_MutexGrpAdd(p_tcb, p_mutex);
;;;885                                                                    /* Post to mutex                                        */
;;;886        OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
;;;887                p_tcb,
;;;888                DEF_NULL,
;;;889                0u,
;;;890                ts);
;;;891    
;;;892        OS_CRITICAL_EXIT_NO_SCHED();
;;;893    
;;;894        if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
;;;895            OSSched();                                              /* Run the scheduler                                    */
;;;896        }
;;;897    
;;;898       *p_err = OS_ERR_NONE;
;;;899    }
00001a  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.30|
00001e  b91c              CBNZ     r4,|L3.40|
000020  f64550c3          MOV      r0,#0x5dc3            ;800
000024  8028              STRH     r0,[r5,#0]            ;800
000026  e7f8              B        |L3.26|
                  |L3.40|
000028  f1b90f00          CMP      r9,#0                 ;803
00002c  d003              BEQ      |L3.54|
00002e  f5b94f00          CMP      r9,#0x8000            ;803
000032  d102              BNE      |L3.58|
000034  e000              B        |L3.56|
                  |L3.54|
000036  bf00              NOP                            ;805
                  |L3.56|
000038  e003              B        |L3.66|
                  |L3.58|
00003a  f6456025          MOV      r0,#0x5e25            ;812
00003e  8028              STRH     r0,[r5,#0]            ;812
000040  e7eb              B        |L3.26|
                  |L3.66|
000042  bf00              NOP                            ;806
000044  4957              LDR      r1,|L3.420|
000046  6820              LDR      r0,[r4,#0]            ;818
000048  4288              CMP      r0,r1                 ;818
00004a  d003              BEQ      |L3.84|
00004c  f64550c4          MOV      r0,#0x5dc4            ;822
000050  8028              STRH     r0,[r5,#0]            ;822
000052  e7e2              B        |L3.26|
                  |L3.84|
000054  bf00              NOP                            ;827
000056  bf00              NOP                            ;827
000058  f7fffffe          BL       CPU_SR_Save
00005c  4683              MOV      r11,r0                ;827
00005e  bf00              NOP                            ;827
000060  f7fffffe          BL       CPU_IntDisMeasStart
000064  bf00              NOP                            ;827
000066  4950              LDR      r1,|L3.424|
000068  6a60              LDR      r0,[r4,#0x24]         ;828
00006a  6809              LDR      r1,[r1,#0]            ;828  ; OSTCBCurPtr
00006c  4288              CMP      r0,r1                 ;828
00006e  d00c              BEQ      |L3.138|
000070  bf00              NOP                            ;829
000072  f7fffffe          BL       CPU_IntDisMeasStop
000076  bf00              NOP                            ;829
000078  4658              MOV      r0,r11                ;829
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  bf00              NOP                            ;829
000080  bf00              NOP                            ;829
000082  f2457081          MOV      r0,#0x5781            ;833
000086  8028              STRH     r0,[r5,#0]            ;833
000088  e7c7              B        |L3.26|
                  |L3.138|
00008a  f7fffffe          BL       CPU_TS_TmrRd
00008e  4680              MOV      r8,r0                 ;843
000090  3428              ADDS     r4,r4,#0x28           ;844
000092  f8c48004          STR      r8,[r4,#4]            ;844
000096  7820              LDRB     r0,[r4,#0]            ;848
000098  1e40              SUBS     r0,r0,#1              ;848
00009a  7020              STRB     r0,[r4,#0]            ;848
00009c  f8140928          LDRB     r0,[r4],#-0x28        ;849
0000a0  b160              CBZ      r0,|L3.188|
0000a2  bf00              NOP                            ;850
0000a4  f7fffffe          BL       CPU_IntDisMeasStop
0000a8  bf00              NOP                            ;850
0000aa  4658              MOV      r0,r11                ;850
0000ac  f7fffffe          BL       CPU_SR_Restore
0000b0  bf00              NOP                            ;850
0000b2  bf00              NOP                            ;850
0000b4  f2457083          MOV      r0,#0x5783            ;851
0000b8  8028              STRH     r0,[r5,#0]            ;851
0000ba  e7ae              B        |L3.26|
                  |L3.188|
0000bc  4621              MOV      r1,r4                 ;855
0000be  483a              LDR      r0,|L3.424|
0000c0  6800              LDR      r0,[r0,#0]            ;855  ; OSTCBCurPtr
0000c2  f7fffffe          BL       OS_MutexGrpRemove
0000c6  f1040a08          ADD      r10,r4,#8             ;857
0000ca  f8da0000          LDR      r0,[r10,#0]           ;858
0000ce  b978              CBNZ     r0,|L3.240|
0000d0  2000              MOVS     r0,#0                 ;859
0000d2  6260              STR      r0,[r4,#0x24]         ;859
0000d4  f8840028          STRB     r0,[r4,#0x28]         ;860
0000d8  bf00              NOP                            ;861
0000da  f7fffffe          BL       CPU_IntDisMeasStop
0000de  bf00              NOP                            ;861
0000e0  4658              MOV      r0,r11                ;861
0000e2  f7fffffe          BL       CPU_SR_Restore
0000e6  bf00              NOP                            ;861
0000e8  bf00              NOP                            ;861
0000ea  2000              MOVS     r0,#0                 ;862
0000ec  8028              STRH     r0,[r5,#0]            ;862
0000ee  e794              B        |L3.26|
                  |L3.240|
0000f0  482d              LDR      r0,|L3.424|
0000f2  6800              LDR      r0,[r0,#0]            ;866  ; OSTCBCurPtr
0000f4  f8900037          LDRB     r0,[r0,#0x37]         ;866
0000f8  492b              LDR      r1,|L3.424|
0000fa  6809              LDR      r1,[r1,#0]            ;866  ; OSTCBCurPtr
0000fc  f8911038          LDRB     r1,[r1,#0x38]         ;866
000100  4288              CMP      r0,r1                 ;866
000102  d028              BEQ      |L3.342|
000104  4828              LDR      r0,|L3.424|
000106  6800              LDR      r0,[r0,#0]            ;867  ; OSTCBCurPtr
000108  f7fffffe          BL       OS_MutexGrpPrioFindHighest
00010c  4606              MOV      r6,r0                 ;867
00010e  4826              LDR      r0,|L3.424|
000110  6800              LDR      r0,[r0,#0]            ;868  ; OSTCBCurPtr
000112  f8901038          LDRB     r1,[r0,#0x38]         ;868
000116  42b1              CMP      r1,r6                 ;868
000118  da04              BGE      |L3.292|
00011a  4823              LDR      r0,|L3.424|
00011c  6800              LDR      r0,[r0,#0]            ;868  ; OSTCBCurPtr
00011e  f8900038          LDRB     r0,[r0,#0x38]         ;868
000122  e000              B        |L3.294|
                  |L3.292|
000124  4630              MOV      r0,r6                 ;868
                  |L3.294|
000126  4606              MOV      r6,r0                 ;868
000128  481f              LDR      r0,|L3.424|
00012a  6800              LDR      r0,[r0,#0]            ;869  ; OSTCBCurPtr
00012c  f8900037          LDRB     r0,[r0,#0x37]         ;869
000130  42b0              CMP      r0,r6                 ;869
000132  da10              BGE      |L3.342|
000134  481c              LDR      r0,|L3.424|
000136  6800              LDR      r0,[r0,#0]            ;870  ; OSTCBCurPtr
000138  f7fffffe          BL       OS_RdyListRemove
00013c  481a              LDR      r0,|L3.424|
00013e  6800              LDR      r0,[r0,#0]            ;871  ; OSTCBCurPtr
000140  f8806037          STRB     r6,[r0,#0x37]         ;871
000144  4630              MOV      r0,r6                 ;875
000146  f7fffffe          BL       OS_PrioInsert
00014a  4817              LDR      r0,|L3.424|
00014c  6800              LDR      r0,[r0,#0]            ;876  ; OSTCBCurPtr
00014e  f7fffffe          BL       OS_RdyListInsertTail
000152  4816              LDR      r0,|L3.428|
000154  7006              STRB     r6,[r0,#0]            ;877
                  |L3.342|
000156  f8da0000          LDR      r0,[r10,#0]           ;881
00015a  6887              LDR      r7,[r0,#8]            ;881
00015c  6267              STR      r7,[r4,#0x24]         ;882
00015e  2001              MOVS     r0,#1                 ;883
000160  f8840028          STRB     r0,[r4,#0x28]         ;883
000164  4621              MOV      r1,r4                 ;884
000166  4638              MOV      r0,r7                 ;884
000168  f7fffffe          BL       OS_MutexGrpAdd
00016c  2300              MOVS     r3,#0                 ;886
00016e  461a              MOV      r2,r3                 ;886
000170  4639              MOV      r1,r7                 ;886
000172  4620              MOV      r0,r4                 ;886
000174  f8cd8000          STR      r8,[sp,#0]            ;886
000178  f7fffffe          BL       OS_Post
00017c  bf00              NOP                            ;892
00017e  f7fffffe          BL       CPU_IntDisMeasStop
000182  bf00              NOP                            ;892
000184  4658              MOV      r0,r11                ;892
000186  f7fffffe          BL       CPU_SR_Restore
00018a  bf00              NOP                            ;892
00018c  bf00              NOP                            ;892
00018e  f4094000          AND      r0,r9,#0x8000         ;894
000192  b908              CBNZ     r0,|L3.408|
000194  f7fffffe          BL       OSSched
                  |L3.408|
000198  2000              MOVS     r0,#0                 ;898
00019a  8028              STRH     r0,[r5,#0]            ;898
00019c  bf00              NOP      
00019e  e73c              B        |L3.26|
;;;900    
                          ENDP

                  |L3.416|
                          DCD      OSIntNestingCtr
                  |L3.420|
                          DCD      0x5854554d
                  |L3.424|
                          DCD      OSTCBCurPtr
                  |L3.428|
                          DCD      OSPrioCur

                          AREA ||i.OS_MutexClr||, CODE, READONLY, ALIGN=2

                  OS_MutexClr PROC
;;;917    
;;;918    void  OS_MutexClr (OS_MUTEX  *p_mutex)
000000  b510              PUSH     {r4,lr}
;;;919    {
000002  4604              MOV      r4,r0
;;;920    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;921        p_mutex->Type              =  OS_OBJ_TYPE_NONE;             /* Mark the data structure as a NONE                    */
000004  4807              LDR      r0,|L4.36|
000006  6020              STR      r0,[r4,#0]
;;;922    #endif
;;;923    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;924        p_mutex->NamePtr           = (CPU_CHAR *)((void *)"?MUTEX");
000008  a007              ADR      r0,|L4.40|
00000a  6060              STR      r0,[r4,#4]
;;;925    #endif
;;;926        p_mutex->MutexGrpNextPtr   = DEF_NULL;
00000c  2000              MOVS     r0,#0
00000e  6220              STR      r0,[r4,#0x20]
;;;927        p_mutex->OwnerTCBPtr       = DEF_NULL;
000010  6260              STR      r0,[r4,#0x24]
;;;928        p_mutex->OwnerNestingCtr   = 0u;
000012  f8840028          STRB     r0,[r4,#0x28]
;;;929    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;930        p_mutex->TS                = 0u;
000016  62e0              STR      r0,[r4,#0x2c]
;;;931    #endif
;;;932        OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
000018  f1040008          ADD      r0,r4,#8
00001c  f7fffffe          BL       OS_PendListInit
;;;933    }
000020  bd10              POP      {r4,pc}
;;;934    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x454e4f4e
                  |L4.40|
000028  3f4d5554          DCB      "?MUTEX",0
00002c  455800  
00002f  00                DCB      0

                          AREA ||i.OS_MutexDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListAdd PROC
;;;951    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;952    void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
000000  a109              ADR      r1,|L5.40|
;;;953    {
;;;954        p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;955        p_mutex->DbgPrevPtr               = DEF_NULL;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;956        if (OSMutexDbgListPtr == DEF_NULL) {
000008  4908              LDR      r1,|L5.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00000c  b911              CBNZ     r1,|L5.20|
;;;957            p_mutex->DbgNextPtr           = DEF_NULL;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L5.32|
                  |L5.20|
;;;958        } else {
;;;959            p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
000014  4905              LDR      r1,|L5.44|
000016  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;960            OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
00001a  4904              LDR      r1,|L5.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L5.32|
;;;961        }
;;;962        OSMutexDbgListPtr                 =  p_mutex;
000020  4902              LDR      r1,|L5.44|
000022  6008              STR      r0,[r1,#0]  ; OSMutexDbgListPtr
;;;963    }
000024  4770              BX       lr
;;;964    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L5.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListRemove PROC
;;;966    
;;;967    void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
000000  6942              LDR      r2,[r0,#0x14]
;;;968    {
;;;969        OS_MUTEX  *p_mutex_next;
;;;970        OS_MUTEX  *p_mutex_prev;
;;;971    
;;;972    
;;;973        p_mutex_prev = p_mutex->DbgPrevPtr;
;;;974        p_mutex_next = p_mutex->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;975    
;;;976        if (p_mutex_prev == DEF_NULL) {
000004  b93a              CBNZ     r2,|L6.22|
;;;977            OSMutexDbgListPtr = p_mutex_next;
000006  4b09              LDR      r3,|L6.44|
000008  6019              STR      r1,[r3,#0]  ; OSMutexDbgListPtr
;;;978            if (p_mutex_next != DEF_NULL) {
00000a  b109              CBZ      r1,|L6.16|
;;;979                p_mutex_next->DbgPrevPtr = DEF_NULL;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L6.16|
;;;980            }
;;;981            p_mutex->DbgNextPtr = DEF_NULL;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L6.42|
                  |L6.22|
;;;982    
;;;983        } else if (p_mutex_next == DEF_NULL) {
000016  b919              CBNZ     r1,|L6.32|
;;;984            p_mutex_prev->DbgNextPtr = DEF_NULL;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;985            p_mutex->DbgPrevPtr      = DEF_NULL;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L6.42|
                  |L6.32|
;;;986    
;;;987        } else {
;;;988            p_mutex_prev->DbgNextPtr =  p_mutex_next;
000020  6191              STR      r1,[r2,#0x18]
;;;989            p_mutex_next->DbgPrevPtr =  p_mutex_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;990            p_mutex->DbgNextPtr      = DEF_NULL;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;991            p_mutex->DbgPrevPtr      = DEF_NULL;
000028  6143              STR      r3,[r0,#0x14]
                  |L6.42|
;;;992        }
;;;993    }
00002a  4770              BX       lr
;;;994    #endif
                          ENDP

                  |L6.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexGrpAdd||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpAdd PROC
;;;1014   
;;;1015   void  OS_MutexGrpAdd (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;1016   {
;;;1017       p_mutex->MutexGrpNextPtr = p_tcb->MutexGrpHeadPtr;      /* The mutex grp is not sorted add to head of list.       */
000002  620a              STR      r2,[r1,#0x20]
;;;1018       p_tcb->MutexGrpHeadPtr   = p_mutex;
000004  63c1              STR      r1,[r0,#0x3c]
;;;1019   }
000006  4770              BX       lr
;;;1020   
                          ENDP


                          AREA ||i.OS_MutexGrpPostAll||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPostAll PROC
;;;1112   
;;;1113   void  OS_MutexGrpPostAll (OS_TCB  *p_tcb)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1114   {
000004  4605              MOV      r5,r0
;;;1115       OS_MUTEX      *p_mutex;
;;;1116       OS_MUTEX      *p_mutex_next;
;;;1117       CPU_TS         ts;
;;;1118       OS_PEND_LIST  *p_pend_list;
;;;1119       OS_TCB        *p_tcb_new;
;;;1120   
;;;1121   
;;;1122       p_mutex = p_tcb->MutexGrpHeadPtr;
000006  6bec              LDR      r4,[r5,#0x3c]
;;;1123   
;;;1124       while(p_mutex != DEF_NULL) {
000008  e026              B        |L8.88|
                  |L8.10|
;;;1125   
;;;1126   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1127       TRACE_OS_MUTEX_POST(p_mutex);                               /* Record the event.                                    */
;;;1128   #endif
;;;1129   
;;;1130           p_mutex_next = p_mutex->MutexGrpNextPtr;
00000a  f8d49020          LDR      r9,[r4,#0x20]
;;;1131   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1132           ts           = OS_TS_GET();                             /* Get timestamp                                        */
00000e  f7fffffe          BL       CPU_TS_TmrRd
000012  4606              MOV      r6,r0
;;;1133           p_mutex->TS  = ts;
000014  62e6              STR      r6,[r4,#0x2c]
;;;1134   #else
;;;1135           ts           = 0u;
;;;1136   #endif
;;;1137           OS_MutexGrpRemove(p_tcb,  p_mutex);                     /* Remove mutex from owner's group                      */
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       OS_MutexGrpRemove
;;;1138   
;;;1139           p_pend_list = &p_mutex->PendList;
00001e  f1040808          ADD      r8,r4,#8
;;;1140           if (p_pend_list->HeadPtr == DEF_NULL) {                 /* Any task waiting on mutex?                           */
000022  f8d80000          LDR      r0,[r8,#0]
000026  b920              CBNZ     r0,|L8.50|
;;;1141               p_mutex->OwnerNestingCtr = 0u;                      /* Decrement owner's nesting counter                    */
000028  2000              MOVS     r0,#0
00002a  f8840028          STRB     r0,[r4,#0x28]
;;;1142               p_mutex->OwnerTCBPtr     = DEF_NULL;                /* No                                                   */
00002e  6260              STR      r0,[r4,#0x24]
000030  e011              B        |L8.86|
                  |L8.50|
;;;1143           } else {
;;;1144                                                                   /* Get TCB from head of pend list                       */
;;;1145               p_tcb_new = p_pend_list->HeadPtr->TCBPtr;
000032  f8d80000          LDR      r0,[r8,#0]
000036  6887              LDR      r7,[r0,#8]
;;;1146               p_mutex->OwnerTCBPtr     = p_tcb;                   /* Give mutex to new owner                              */
000038  6265              STR      r5,[r4,#0x24]
;;;1147               p_mutex->OwnerNestingCtr = 1u;
00003a  2001              MOVS     r0,#1
00003c  f8840028          STRB     r0,[r4,#0x28]
;;;1148               OS_MutexGrpAdd(p_tcb_new, p_mutex);
000040  4621              MOV      r1,r4
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       OS_MutexGrpAdd
;;;1149                                                                   /* Post to mutex                                        */
;;;1150               OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
000048  2300              MOVS     r3,#0
00004a  461a              MOV      r2,r3
00004c  4639              MOV      r1,r7
00004e  4620              MOV      r0,r4
000050  9600              STR      r6,[sp,#0]
000052  f7fffffe          BL       OS_Post
                  |L8.86|
;;;1151                                               p_tcb_new,
;;;1152                                               DEF_NULL,
;;;1153                                               0u,
;;;1154                                               ts);
;;;1155           }
;;;1156   
;;;1157           p_mutex = p_mutex_next;
000056  464c              MOV      r4,r9
                  |L8.88|
000058  2c00              CMP      r4,#0                 ;1124
00005a  d1d6              BNE      |L8.10|
;;;1158       }
;;;1159   
;;;1160   }
00005c  e8bd83f8          POP      {r3-r9,pc}
;;;1161   
                          ENDP


                          AREA ||i.OS_MutexGrpPrioFindHighest||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPrioFindHighest PROC
;;;1069   
;;;1070   OS_PRIO  OS_MutexGrpPrioFindHighest (OS_TCB  *p_tcb)
000000  b530              PUSH     {r4,r5,lr}
;;;1071   {
000002  4604              MOV      r4,r0
;;;1072       OS_MUTEX     **pp_mutex;
;;;1073       OS_PRIO        highest_prio;
;;;1074       OS_PRIO        prio;
;;;1075       OS_PEND_DATA  *p_head;
;;;1076   
;;;1077   
;;;1078       highest_prio = OS_CFG_PRIO_MAX - 1u;
000004  201f              MOVS     r0,#0x1f
;;;1079       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000006  f104013c          ADD      r1,r4,#0x3c
;;;1080   
;;;1081       while(*pp_mutex != DEF_NULL) {
00000a  e00b              B        |L9.36|
                  |L9.12|
;;;1082           p_head = (*pp_mutex)->PendList.HeadPtr;
00000c  680d              LDR      r5,[r1,#0]
00000e  68ab              LDR      r3,[r5,#8]
;;;1083           if (p_head!= DEF_NULL) {
000010  b12b              CBZ      r3,|L9.30|
;;;1084               prio = p_head->TCBPtr->Prio;
000012  689d              LDR      r5,[r3,#8]
000014  f8952037          LDRB     r2,[r5,#0x37]
;;;1085               if(prio < highest_prio) {
000018  4282              CMP      r2,r0
00001a  da00              BGE      |L9.30|
;;;1086                   highest_prio = prio;
00001c  4610              MOV      r0,r2
                  |L9.30|
;;;1087               }
;;;1088           }
;;;1089           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
00001e  680d              LDR      r5,[r1,#0]
000020  f1050120          ADD      r1,r5,#0x20
                  |L9.36|
000024  680d              LDR      r5,[r1,#0]            ;1081
000026  2d00              CMP      r5,#0                 ;1081
000028  d1f0              BNE      |L9.12|
;;;1090       }
;;;1091   
;;;1092       return (highest_prio);
;;;1093   }
00002a  bd30              POP      {r4,r5,pc}
;;;1094   
                          ENDP


                          AREA ||i.OS_MutexGrpRemove||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpRemove PROC
;;;1039   
;;;1040   void  OS_MutexGrpRemove (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  4602              MOV      r2,r0
;;;1041   {
;;;1042       OS_MUTEX  **pp_mutex;
;;;1043   
;;;1044       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000002  f102003c          ADD      r0,r2,#0x3c
;;;1045   
;;;1046       while(*pp_mutex != p_mutex) {
000006  e002              B        |L10.14|
                  |L10.8|
;;;1047           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
000008  6803              LDR      r3,[r0,#0]
00000a  f1030020          ADD      r0,r3,#0x20
                  |L10.14|
00000e  6803              LDR      r3,[r0,#0]            ;1046
000010  428b              CMP      r3,r1                 ;1046
000012  d1f9              BNE      |L10.8|
;;;1048       }
;;;1049   
;;;1050       *pp_mutex = (*pp_mutex)->MutexGrpNextPtr;
000014  6803              LDR      r3,[r0,#0]
000016  6a1b              LDR      r3,[r3,#0x20]
000018  6003              STR      r3,[r0,#0]
;;;1051   }
00001a  4770              BX       lr
;;;1052   
                          ENDP

