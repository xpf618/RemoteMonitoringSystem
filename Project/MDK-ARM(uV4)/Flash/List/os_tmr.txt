; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_tmr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_tmr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -IH:\½øÐÐÊ±\CS_System_Program\Project\MDK-ARM(uV4)\RTE -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\os_tmr.crf ..\..\uCOS-III\uCOS-III\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;104    
;;;105    void  OSTmrCreate (OS_TMR               *p_tmr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;106                       CPU_CHAR             *p_name,
;;;107                       OS_TICK               dly,
;;;108                       OS_TICK               period,
;;;109                       OS_OPT                opt,
;;;110                       OS_TMR_CALLBACK_PTR   p_callback,
;;;111                       void                 *p_callback_arg,
;;;112                       OS_ERR               *p_err)
;;;113    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
000014  9d0d              LDR      r5,[sp,#0x34]
;;;114    #ifdef OS_SAFETY_CRITICAL
;;;115        if (p_err == DEF_NULL) {
;;;116            OS_SAFETY_CRITICAL_EXCEPTION();
;;;117            return;
;;;118        }
;;;119    #endif
;;;120    
;;;121    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;122        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;123           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;124            return;
;;;125        }
;;;126    #endif
;;;127    
;;;128    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;129        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000016  482b              LDR      r0,|L1.196|
000018  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00001a  b120              CBZ      r0,|L1.38|
;;;130           *p_err = OS_ERR_TMR_ISR;
00001c  f2473043          MOV      r0,#0x7343
000020  8028              STRH     r0,[r5,#0]
                  |L1.34|
;;;131            return;
;;;132        }
;;;133    #endif
;;;134    
;;;135    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;136        if (p_tmr == DEF_NULL) {                                    /* Validate 'p_tmr'                                     */
;;;137           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;138            return;
;;;139        }
;;;140    
;;;141        switch (opt) {
;;;142            case OS_OPT_TMR_PERIODIC:
;;;143                 if (period == 0u) {
;;;144                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;145                     return;
;;;146                 }
;;;147    
;;;148                 if (p_callback == DEF_NULL) {                      /* No point in a periodic timer without a callback      */
;;;149                    *p_err = OS_ERR_TMR_INVALID_CALLBACK;
;;;150                     return;
;;;151                 }
;;;152                 break;
;;;153    
;;;154            case OS_OPT_TMR_ONE_SHOT:
;;;155                 if (dly == 0u) {
;;;156                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;157                     return;
;;;158                 }
;;;159                 break;
;;;160    
;;;161            default:
;;;162                *p_err = OS_ERR_OPT_INVALID;
;;;163                 return;
;;;164        }
;;;165    #endif
;;;166    
;;;167        if (OSRunning == OS_STATE_OS_RUNNING) {                     /* Only lock when the kernel is running                 */
;;;168            OS_TmrLock();
;;;169        }
;;;170    
;;;171        p_tmr->State          = OS_TMR_STATE_STOPPED;               /* Initialize the timer fields                          */
;;;172    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;173        p_tmr->Type           = OS_OBJ_TYPE_TMR;
;;;174    #endif
;;;175    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;176        p_tmr->NamePtr        = p_name;
;;;177    #else
;;;178        (void)&p_name;
;;;179    #endif
;;;180        p_tmr->Dly            = dly;
;;;181        p_tmr->Remain         = 0u;
;;;182        p_tmr->Period         = period;
;;;183        p_tmr->Opt            = opt;
;;;184        p_tmr->CallbackPtr    = p_callback;
;;;185        p_tmr->CallbackPtrArg = p_callback_arg;
;;;186        p_tmr->NextPtr        = DEF_NULL;
;;;187        p_tmr->PrevPtr        = DEF_NULL;
;;;188    
;;;189    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;190        OS_TmrDbgListAdd(p_tmr);
;;;191    #endif
;;;192    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;193        OSTmrQty++;                                                 /* Keep track of the number of timers created           */
;;;194    #endif
;;;195    
;;;196        if (OSRunning == OS_STATE_OS_RUNNING) {
;;;197            OS_TmrUnlock();
;;;198        }
;;;199    
;;;200       *p_err = OS_ERR_NONE;
;;;201    }
000022  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.38|
000026  b91c              CBNZ     r4,|L1.48|
000028  f64550c3          MOV      r0,#0x5dc3            ;137
00002c  8028              STRH     r0,[r5,#0]            ;137
00002e  e7f8              B        |L1.34|
                  |L1.48|
000030  f1b90f01          CMP      r9,#1                 ;141
000034  d00f              BEQ      |L1.86|
000036  f1b90f02          CMP      r9,#2                 ;141
00003a  d112              BNE      |L1.98|
00003c  b91f              CBNZ     r7,|L1.70|
00003e  f2473040          MOV      r0,#0x7340            ;144
000042  8028              STRH     r0,[r5,#0]            ;144
000044  e7ed              B        |L1.34|
                  |L1.70|
000046  f1ba0f00          CMP      r10,#0                ;148
00004a  d103              BNE      |L1.84|
00004c  f247304a          MOV      r0,#0x734a            ;149
000050  8028              STRH     r0,[r5,#0]            ;149
000052  e7e6              B        |L1.34|
                  |L1.84|
000054  e009              B        |L1.106|
                  |L1.86|
000056  b91e              CBNZ     r6,|L1.96|
000058  f247303f          MOV      r0,#0x733f            ;156
00005c  8028              STRH     r0,[r5,#0]            ;156
00005e  e7e0              B        |L1.34|
                  |L1.96|
000060  e003              B        |L1.106|
                  |L1.98|
000062  f6456025          MOV      r0,#0x5e25            ;162
000066  8028              STRH     r0,[r5,#0]            ;162
000068  e7db              B        |L1.34|
                  |L1.106|
00006a  bf00              NOP                            ;152
00006c  4816              LDR      r0,|L1.200|
00006e  7800              LDRB     r0,[r0,#0]            ;167  ; OSRunning
000070  2801              CMP      r0,#1                 ;167
000072  d101              BNE      |L1.120|
000074  f7fffffe          BL       OS_TmrLock
                  |L1.120|
000078  2001              MOVS     r0,#1                 ;171
00007a  f8840026          STRB     r0,[r4,#0x26]         ;171
00007e  4813              LDR      r0,|L1.204|
000080  6020              STR      r0,[r4,#0]            ;173
000082  f8c48004          STR      r8,[r4,#4]            ;176
000086  61e6              STR      r6,[r4,#0x1c]         ;180
000088  2000              MOVS     r0,#0                 ;181
00008a  61a0              STR      r0,[r4,#0x18]         ;181
00008c  6227              STR      r7,[r4,#0x20]         ;182
00008e  f8a49024          STRH     r9,[r4,#0x24]         ;183
000092  f8c4a008          STR      r10,[r4,#8]           ;184
000096  f8c4b00c          STR      r11,[r4,#0xc]         ;185
00009a  6120              STR      r0,[r4,#0x10]         ;186
00009c  6160              STR      r0,[r4,#0x14]         ;187
00009e  4620              MOV      r0,r4                 ;190
0000a0  f7fffffe          BL       OS_TmrDbgListAdd
0000a4  480a              LDR      r0,|L1.208|
0000a6  8800              LDRH     r0,[r0,#0]            ;193  ; OSTmrQty
0000a8  1c40              ADDS     r0,r0,#1              ;193
0000aa  4909              LDR      r1,|L1.208|
0000ac  8008              STRH     r0,[r1,#0]            ;193
0000ae  4806              LDR      r0,|L1.200|
0000b0  7800              LDRB     r0,[r0,#0]            ;196  ; OSRunning
0000b2  2801              CMP      r0,#1                 ;196
0000b4  d101              BNE      |L1.186|
0000b6  f7fffffe          BL       OS_TmrUnlock
                  |L1.186|
0000ba  2000              MOVS     r0,#0                 ;200
0000bc  8028              STRH     r0,[r5,#0]            ;200
0000be  bf00              NOP      
0000c0  e7af              B        |L1.34|
;;;202    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L1.196|
                          DCD      OSIntNestingCtr
                  |L1.200|
                          DCD      OSRunning
                  |L1.204|
                          DCD      0x20524d54
                  |L1.208|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;351    
;;;352    OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;353                             OS_ERR  *p_err)
;;;354    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;355        OS_TICK  remain;
;;;356    
;;;357    
;;;358    #ifdef OS_SAFETY_CRITICAL
;;;359        if (p_err == DEF_NULL) {
;;;360            OS_SAFETY_CRITICAL_EXCEPTION();
;;;361            return (0u);
;;;362        }
;;;363    #endif
;;;364    
;;;365    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;366        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000006  4823              LDR      r0,|L2.148|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b120              CBZ      r0,|L2.22|
;;;367           *p_err = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
000010  8028              STRH     r0,[r5,#0]
;;;368            return (0u);
000012  2000              MOVS     r0,#0
                  |L2.20|
;;;369        }
;;;370    #endif
;;;371    
;;;372    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;373        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;374           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;375            return (0u);
;;;376        }
;;;377    #endif
;;;378    
;;;379    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;380        if (p_tmr == DEF_NULL) {
;;;381           *p_err = OS_ERR_TMR_INVALID;
;;;382            return (0u);
;;;383        }
;;;384    #endif
;;;385    
;;;386    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;387        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;388           *p_err = OS_ERR_OBJ_TYPE;
;;;389            return (0u);
;;;390        }
;;;391    #endif
;;;392    
;;;393        OS_TmrLock();
;;;394    
;;;395        switch (p_tmr->State) {
;;;396            case OS_TMR_STATE_RUNNING:
;;;397                 remain = p_tmr->Remain;
;;;398                *p_err  = OS_ERR_NONE;
;;;399                 break;
;;;400    
;;;401            case OS_TMR_STATE_STOPPED:                              /* It's assumed that the timer has not started yet      */
;;;402                 if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
;;;403                     if (p_tmr->Dly == 0u) {
;;;404                         remain = p_tmr->Period;
;;;405                     } else {
;;;406                         remain = p_tmr->Dly;
;;;407                     }
;;;408                 } else {
;;;409                     remain = p_tmr->Dly;
;;;410                 }
;;;411                *p_err = OS_ERR_NONE;
;;;412                 break;
;;;413    
;;;414            case OS_TMR_STATE_COMPLETED:                            /* Only ONE-SHOT that timed out can be in this state    */
;;;415                *p_err  = OS_ERR_NONE;
;;;416                 remain = 0u;
;;;417                 break;
;;;418    
;;;419            case OS_TMR_STATE_UNUSED:
;;;420                *p_err  = OS_ERR_TMR_INACTIVE;
;;;421                 remain = 0u;
;;;422                 break;
;;;423    
;;;424            default:
;;;425                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;426                 remain = 0u;
;;;427                 break;
;;;428        }
;;;429    
;;;430        OS_TmrUnlock();
;;;431    
;;;432        return (remain);
;;;433    }
000014  bd70              POP      {r4-r6,pc}
                  |L2.22|
000016  b924              CBNZ     r4,|L2.34|
000018  f2473042          MOV      r0,#0x7342            ;381
00001c  8028              STRH     r0,[r5,#0]            ;381
00001e  2000              MOVS     r0,#0                 ;382
000020  e7f8              B        |L2.20|
                  |L2.34|
000022  491d              LDR      r1,|L2.152|
000024  6820              LDR      r0,[r4,#0]            ;387
000026  4288              CMP      r0,r1                 ;387
000028  d004              BEQ      |L2.52|
00002a  f64550c4          MOV      r0,#0x5dc4            ;388
00002e  8028              STRH     r0,[r5,#0]            ;388
000030  2000              MOVS     r0,#0                 ;389
000032  e7ef              B        |L2.20|
                  |L2.52|
000034  f7fffffe          BL       OS_TmrLock
000038  f8940026          LDRB     r0,[r4,#0x26]         ;395
00003c  b1d8              CBZ      r0,|L2.118|
00003e  2801              CMP      r0,#1                 ;395
000040  d008              BEQ      |L2.84|
000042  2802              CMP      r0,#2                 ;395
000044  d002              BEQ      |L2.76|
000046  2803              CMP      r0,#3                 ;395
000048  d11a              BNE      |L2.128|
00004a  e010              B        |L2.110|
                  |L2.76|
00004c  69a6              LDR      r6,[r4,#0x18]         ;397
00004e  2000              MOVS     r0,#0                 ;398
000050  8028              STRH     r0,[r5,#0]            ;398
000052  e01a              B        |L2.138|
                  |L2.84|
000054  8ca0              LDRH     r0,[r4,#0x24]         ;402
000056  2802              CMP      r0,#2                 ;402
000058  d105              BNE      |L2.102|
00005a  69e0              LDR      r0,[r4,#0x1c]         ;403
00005c  b908              CBNZ     r0,|L2.98|
00005e  6a26              LDR      r6,[r4,#0x20]         ;404
000060  e002              B        |L2.104|
                  |L2.98|
000062  69e6              LDR      r6,[r4,#0x1c]         ;406
000064  e000              B        |L2.104|
                  |L2.102|
000066  69e6              LDR      r6,[r4,#0x1c]         ;409
                  |L2.104|
000068  2000              MOVS     r0,#0                 ;411
00006a  8028              STRH     r0,[r5,#0]            ;411
00006c  e00d              B        |L2.138|
                  |L2.110|
00006e  2000              MOVS     r0,#0                 ;415
000070  8028              STRH     r0,[r5,#0]            ;415
000072  2600              MOVS     r6,#0                 ;416
000074  e009              B        |L2.138|
                  |L2.118|
000076  f247303d          MOV      r0,#0x733d            ;420
00007a  8028              STRH     r0,[r5,#0]            ;420
00007c  2600              MOVS     r6,#0                 ;421
00007e  e004              B        |L2.138|
                  |L2.128|
000080  f2473041          MOV      r0,#0x7341            ;425
000084  8028              STRH     r0,[r5,#0]            ;425
000086  2600              MOVS     r6,#0                 ;426
000088  bf00              NOP                            ;427
                  |L2.138|
00008a  bf00              NOP                            ;399
00008c  f7fffffe          BL       OS_TmrUnlock
000090  4630              MOV      r0,r6                 ;432
000092  e7bf              B        |L2.20|
;;;434    
                          ENDP

                  |L2.148|
                          DCD      OSIntNestingCtr
                  |L2.152|
                          DCD      0x20524d54

                          AREA ||i.OSTmrSet||, CODE, READONLY, ALIGN=2

                  OSTmrSet PROC
;;;478    
;;;479    void  OSTmrSet (OS_TMR               *p_tmr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;480                    OS_TICK               dly,
;;;481                    OS_TICK               period,
;;;482                    OS_TMR_CALLBACK_PTR   p_callback,
;;;483                    void                 *p_callback_arg,
;;;484                    OS_ERR               *p_err)
;;;485    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9508          LDRD     r9,r5,[sp,#0x20]
;;;486    #ifdef OS_SAFETY_CRITICAL
;;;487        if (p_err == DEF_NULL) {
;;;488            OS_SAFETY_CRITICAL_EXCEPTION();
;;;489            return;
;;;490        }
;;;491    #endif
;;;492    
;;;493    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;494        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000010  481f              LDR      r0,|L3.144|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  b120              CBZ      r0,|L3.32|
;;;495           *p_err = OS_ERR_TMR_ISR;
000016  f2473043          MOV      r0,#0x7343
00001a  8028              STRH     r0,[r5,#0]
                  |L3.28|
;;;496            return;
;;;497        }
;;;498    #endif
;;;499    
;;;500    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;501        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;502           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;503            return;
;;;504        }
;;;505    #endif
;;;506    
;;;507    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;508        if (p_tmr == DEF_NULL) {                                    /* Validate 'p_tmr'                                     */
;;;509           *p_err = OS_ERR_TMR_INVALID;
;;;510            return;
;;;511        }
;;;512    #endif
;;;513    
;;;514    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;515        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;516           *p_err = OS_ERR_OBJ_TYPE;
;;;517            return;
;;;518        }
;;;519    #endif
;;;520    
;;;521    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;522        switch (p_tmr->Opt) {
;;;523            case OS_OPT_TMR_PERIODIC:
;;;524                 if (period == 0u) {
;;;525                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;526                     return;
;;;527                 }
;;;528    
;;;529                 if (p_callback == DEF_NULL) {                      /* No point in a periodic timer without a callback      */
;;;530                    *p_err = OS_ERR_TMR_INVALID_CALLBACK;
;;;531                     return;
;;;532                 }
;;;533                 break;
;;;534    
;;;535            case OS_OPT_TMR_ONE_SHOT:
;;;536                 if (dly == 0u) {
;;;537                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;538                     return;
;;;539                 }
;;;540                 break;
;;;541    
;;;542            default:
;;;543                *p_err = OS_ERR_TMR_INVALID;
;;;544                 return;
;;;545        }
;;;546    #endif
;;;547    
;;;548        OS_TmrLock();
;;;549    
;;;550        p_tmr->Dly            = dly;
;;;551        p_tmr->Period         = period;
;;;552        p_tmr->CallbackPtr    = p_callback;
;;;553        p_tmr->CallbackPtrArg = p_callback_arg;
;;;554    
;;;555       *p_err = OS_ERR_NONE;
;;;556    
;;;557        OS_TmrUnlock();
;;;558    
;;;559    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L3.32|
000020  b91c              CBNZ     r4,|L3.42|
000022  f2473042          MOV      r0,#0x7342            ;509
000026  8028              STRH     r0,[r5,#0]            ;509
000028  e7f8              B        |L3.28|
                  |L3.42|
00002a  491a              LDR      r1,|L3.148|
00002c  6820              LDR      r0,[r4,#0]            ;515
00002e  4288              CMP      r0,r1                 ;515
000030  d003              BEQ      |L3.58|
000032  f64550c4          MOV      r0,#0x5dc4            ;516
000036  8028              STRH     r0,[r5,#0]            ;516
000038  e7f0              B        |L3.28|
                  |L3.58|
00003a  8ca0              LDRH     r0,[r4,#0x24]         ;522
00003c  2801              CMP      r0,#1                 ;522
00003e  d00e              BEQ      |L3.94|
000040  2802              CMP      r0,#2                 ;522
000042  d112              BNE      |L3.106|
000044  b91f              CBNZ     r7,|L3.78|
000046  f2473040          MOV      r0,#0x7340            ;525
00004a  8028              STRH     r0,[r5,#0]            ;525
00004c  e7e6              B        |L3.28|
                  |L3.78|
00004e  f1b80f00          CMP      r8,#0                 ;529
000052  d103              BNE      |L3.92|
000054  f247304a          MOV      r0,#0x734a            ;530
000058  8028              STRH     r0,[r5,#0]            ;530
00005a  e7df              B        |L3.28|
                  |L3.92|
00005c  e009              B        |L3.114|
                  |L3.94|
00005e  b91e              CBNZ     r6,|L3.104|
000060  f247303f          MOV      r0,#0x733f            ;537
000064  8028              STRH     r0,[r5,#0]            ;537
000066  e7d9              B        |L3.28|
                  |L3.104|
000068  e003              B        |L3.114|
                  |L3.106|
00006a  f2473042          MOV      r0,#0x7342            ;543
00006e  8028              STRH     r0,[r5,#0]            ;543
000070  e7d4              B        |L3.28|
                  |L3.114|
000072  bf00              NOP                            ;533
000074  f7fffffe          BL       OS_TmrLock
000078  61e6              STR      r6,[r4,#0x1c]         ;550
00007a  6227              STR      r7,[r4,#0x20]         ;551
00007c  f8c48008          STR      r8,[r4,#8]            ;552
000080  f8c4900c          STR      r9,[r4,#0xc]          ;553
000084  2000              MOVS     r0,#0                 ;555
000086  8028              STRH     r0,[r5,#0]            ;555
000088  f7fffffe          BL       OS_TmrUnlock
00008c  bf00              NOP      
00008e  e7c5              B        |L3.28|
;;;560    
                          ENDP

                  |L3.144|
                          DCD      OSIntNestingCtr
                  |L3.148|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;589    
;;;590    CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;591                             OS_ERR  *p_err)
;;;592    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;593        OS_TMR      *p_next;
;;;594        CPU_BOOLEAN  success;
;;;595    
;;;596        
;;;597    
;;;598    #ifdef OS_SAFETY_CRITICAL
;;;599        if (p_err == DEF_NULL) {
;;;600            OS_SAFETY_CRITICAL_EXCEPTION();
;;;601            return (DEF_FALSE);
;;;602        }
;;;603    #endif
;;;604    
;;;605    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;606        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000008  4831              LDR      r0,|L4.208|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  b128              CBZ      r0,|L4.26|
;;;607           *p_err = OS_ERR_TMR_ISR;
00000e  f2473043          MOV      r0,#0x7343
000012  8028              STRH     r0,[r5,#0]
;;;608            return (DEF_FALSE);
000014  2000              MOVS     r0,#0
                  |L4.22|
;;;609        }
;;;610    #endif
;;;611    
;;;612    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;613        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;614           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;615            return (DEF_FALSE);
;;;616        }
;;;617    #endif
;;;618    
;;;619    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;620        if (p_tmr == DEF_NULL) {
;;;621           *p_err = OS_ERR_TMR_INVALID;
;;;622            return (DEF_FALSE);
;;;623        }
;;;624    #endif
;;;625    
;;;626    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;627        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;628           *p_err = OS_ERR_OBJ_TYPE;
;;;629            return (DEF_FALSE);
;;;630        }
;;;631    #endif
;;;632    
;;;633        OS_TmrLock();
;;;634    
;;;635        switch (p_tmr->State) {
;;;636            case OS_TMR_STATE_RUNNING:                              /* Restart the timer                                    */
;;;637                 p_tmr->Remain = p_tmr->Dly;
;;;638                *p_err         = OS_ERR_NONE;
;;;639                 success       = DEF_TRUE;
;;;640                 break;
;;;641    
;;;642            case OS_TMR_STATE_STOPPED:                              /* Start the timer                                      */
;;;643            case OS_TMR_STATE_COMPLETED:
;;;644                 p_tmr->State  = OS_TMR_STATE_RUNNING;
;;;645                 if (p_tmr->Dly == 0u) {
;;;646                     p_tmr->Remain = p_tmr->Period;
;;;647                 } else {
;;;648                     p_tmr->Remain = p_tmr->Dly;
;;;649                 }
;;;650                 if (OSTmrListPtr ==  DEF_NULL) {                   /* Link into timer list                                 */
;;;651                     p_tmr->NextPtr   = DEF_NULL;                   /* This is the first timer in the list                  */
;;;652                     p_tmr->PrevPtr   = DEF_NULL;
;;;653                     OSTmrListPtr     = p_tmr;
;;;654    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;655                     OSTmrListEntries = 1u;
;;;656    #endif
;;;657                 } else {
;;;658                     p_next           = OSTmrListPtr;               /* Insert at the beginning of the list                  */
;;;659                     p_tmr->NextPtr   = OSTmrListPtr;
;;;660                     p_tmr->PrevPtr   = DEF_NULL;
;;;661                     p_next->PrevPtr  = p_tmr;
;;;662                     OSTmrListPtr     = p_tmr;
;;;663    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;664                     OSTmrListEntries++;
;;;665    #endif
;;;666                 }
;;;667                *p_err   = OS_ERR_NONE;
;;;668                 success = DEF_TRUE;
;;;669                 break;
;;;670    
;;;671            case OS_TMR_STATE_UNUSED:                               /* Timer not created                                    */
;;;672                *p_err   = OS_ERR_TMR_INACTIVE;
;;;673                 success = DEF_FALSE;
;;;674                 break;
;;;675    
;;;676            default:
;;;677                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;678                 success = DEF_FALSE;
;;;679                 break;
;;;680        }
;;;681    
;;;682        OS_TmrUnlock();
;;;683    
;;;684        return (success);
;;;685    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L4.26|
00001a  b924              CBNZ     r4,|L4.38|
00001c  f2473042          MOV      r0,#0x7342            ;621
000020  8028              STRH     r0,[r5,#0]            ;621
000022  2000              MOVS     r0,#0                 ;622
000024  e7f7              B        |L4.22|
                  |L4.38|
000026  492b              LDR      r1,|L4.212|
000028  6820              LDR      r0,[r4,#0]            ;627
00002a  4288              CMP      r0,r1                 ;627
00002c  d004              BEQ      |L4.56|
00002e  f64550c4          MOV      r0,#0x5dc4            ;628
000032  8028              STRH     r0,[r5,#0]            ;628
000034  2000              MOVS     r0,#0                 ;629
000036  e7ee              B        |L4.22|
                  |L4.56|
000038  f7fffffe          BL       OS_TmrLock
00003c  f8940026          LDRB     r0,[r4,#0x26]         ;635
000040  2800              CMP      r0,#0                 ;635
000042  d035              BEQ      |L4.176|
000044  2801              CMP      r0,#1                 ;635
000046  d00a              BEQ      |L4.94|
000048  2802              CMP      r0,#2                 ;635
00004a  d002              BEQ      |L4.82|
00004c  2803              CMP      r0,#3                 ;635
00004e  d134              BNE      |L4.186|
000050  e006              B        |L4.96|
                  |L4.82|
000052  69e0              LDR      r0,[r4,#0x1c]         ;637
000054  61a0              STR      r0,[r4,#0x18]         ;637
000056  2000              MOVS     r0,#0                 ;638
000058  8028              STRH     r0,[r5,#0]            ;638
00005a  2601              MOVS     r6,#1                 ;639
00005c  e032              B        |L4.196|
                  |L4.94|
00005e  bf00              NOP                            ;643
                  |L4.96|
000060  2002              MOVS     r0,#2                 ;644
000062  f8840026          STRB     r0,[r4,#0x26]         ;644
000066  69e0              LDR      r0,[r4,#0x1c]         ;645
000068  b910              CBNZ     r0,|L4.112|
00006a  6a20              LDR      r0,[r4,#0x20]         ;646
00006c  61a0              STR      r0,[r4,#0x18]         ;646
00006e  e001              B        |L4.116|
                  |L4.112|
000070  69e0              LDR      r0,[r4,#0x1c]         ;648
000072  61a0              STR      r0,[r4,#0x18]         ;648
                  |L4.116|
000074  4818              LDR      r0,|L4.216|
000076  6800              LDR      r0,[r0,#0]            ;650  ; OSTmrListPtr
000078  b940              CBNZ     r0,|L4.140|
00007a  2000              MOVS     r0,#0                 ;651
00007c  6120              STR      r0,[r4,#0x10]         ;651
00007e  6160              STR      r0,[r4,#0x14]         ;652
000080  4815              LDR      r0,|L4.216|
000082  6004              STR      r4,[r0,#0]            ;653  ; OSTmrListPtr
000084  2001              MOVS     r0,#1                 ;655
000086  4915              LDR      r1,|L4.220|
000088  8008              STRH     r0,[r1,#0]            ;655
00008a  e00d              B        |L4.168|
                  |L4.140|
00008c  4812              LDR      r0,|L4.216|
00008e  6807              LDR      r7,[r0,#0]            ;658  ; OSTmrListPtr
000090  6800              LDR      r0,[r0,#0]            ;659  ; OSTmrListPtr
000092  6120              STR      r0,[r4,#0x10]         ;659
000094  2000              MOVS     r0,#0                 ;660
000096  6160              STR      r0,[r4,#0x14]         ;660
000098  617c              STR      r4,[r7,#0x14]         ;661
00009a  480f              LDR      r0,|L4.216|
00009c  6004              STR      r4,[r0,#0]            ;662  ; OSTmrListPtr
00009e  480f              LDR      r0,|L4.220|
0000a0  8800              LDRH     r0,[r0,#0]            ;664  ; OSTmrListEntries
0000a2  1c40              ADDS     r0,r0,#1              ;664
0000a4  490d              LDR      r1,|L4.220|
0000a6  8008              STRH     r0,[r1,#0]            ;664
                  |L4.168|
0000a8  2000              MOVS     r0,#0                 ;667
0000aa  8028              STRH     r0,[r5,#0]            ;667
0000ac  2601              MOVS     r6,#1                 ;668
0000ae  e009              B        |L4.196|
                  |L4.176|
0000b0  f247303d          MOV      r0,#0x733d            ;672
0000b4  8028              STRH     r0,[r5,#0]            ;672
0000b6  2600              MOVS     r6,#0                 ;673
0000b8  e004              B        |L4.196|
                  |L4.186|
0000ba  f2473041          MOV      r0,#0x7341            ;677
0000be  8028              STRH     r0,[r5,#0]            ;677
0000c0  2600              MOVS     r6,#0                 ;678
0000c2  bf00              NOP                            ;679
                  |L4.196|
0000c4  bf00              NOP                            ;640
0000c6  f7fffffe          BL       OS_TmrUnlock
0000ca  4630              MOV      r0,r6                 ;684
0000cc  e7a3              B        |L4.22|
;;;686    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L4.208|
                          DCD      OSIntNestingCtr
                  |L4.212|
                          DCD      0x20524d54
                  |L4.216|
                          DCD      OSTmrListPtr
                  |L4.220|
                          DCD      OSTmrListEntries

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;715    
;;;716    OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;717                             OS_ERR  *p_err)
;;;718    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;719        OS_STATE  state;
;;;720    
;;;721    
;;;722    
;;;723    #ifdef OS_SAFETY_CRITICAL
;;;724        if (p_err == DEF_NULL) {
;;;725            OS_SAFETY_CRITICAL_EXCEPTION();
;;;726            return (OS_TMR_STATE_UNUSED);
;;;727        }
;;;728    #endif
;;;729    
;;;730    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;731        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000006  4819              LDR      r0,|L5.108|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b120              CBZ      r0,|L5.22|
;;;732           *p_err = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
000010  8020              STRH     r0,[r4,#0]
;;;733            return (OS_TMR_STATE_UNUSED);
000012  2000              MOVS     r0,#0
                  |L5.20|
;;;734        }
;;;735    #endif
;;;736    
;;;737    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;738        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;739           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;740            return (OS_TMR_STATE_UNUSED);
;;;741        }
;;;742    #endif
;;;743    
;;;744    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;745        if (p_tmr == DEF_NULL) {
;;;746           *p_err = OS_ERR_TMR_INVALID;
;;;747            return (OS_TMR_STATE_UNUSED);
;;;748        }
;;;749    #endif
;;;750    
;;;751    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;752        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;753           *p_err = OS_ERR_OBJ_TYPE;
;;;754            return (OS_TMR_STATE_UNUSED);
;;;755        }
;;;756    #endif
;;;757    
;;;758        OS_TmrLock();
;;;759    
;;;760        state = p_tmr->State;
;;;761        switch (state) {
;;;762            case OS_TMR_STATE_UNUSED:
;;;763            case OS_TMR_STATE_STOPPED:
;;;764            case OS_TMR_STATE_COMPLETED:
;;;765            case OS_TMR_STATE_RUNNING:
;;;766                *p_err = OS_ERR_NONE;
;;;767                 break;
;;;768    
;;;769            default:
;;;770                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;771                 break;
;;;772        }
;;;773    
;;;774        OS_TmrUnlock();
;;;775    
;;;776        return (state);
;;;777    }
000014  bd70              POP      {r4-r6,pc}
                  |L5.22|
000016  b925              CBNZ     r5,|L5.34|
000018  f2473042          MOV      r0,#0x7342            ;746
00001c  8020              STRH     r0,[r4,#0]            ;746
00001e  2000              MOVS     r0,#0                 ;747
000020  e7f8              B        |L5.20|
                  |L5.34|
000022  4913              LDR      r1,|L5.112|
000024  6828              LDR      r0,[r5,#0]            ;752
000026  4288              CMP      r0,r1                 ;752
000028  d004              BEQ      |L5.52|
00002a  f64550c4          MOV      r0,#0x5dc4            ;753
00002e  8020              STRH     r0,[r4,#0]            ;753
000030  2000              MOVS     r0,#0                 ;754
000032  e7ef              B        |L5.20|
                  |L5.52|
000034  f7fffffe          BL       OS_TmrLock
000038  f8956026          LDRB     r6,[r5,#0x26]         ;760
00003c  b136              CBZ      r6,|L5.76|
00003e  2e01              CMP      r6,#1                 ;761
000040  d005              BEQ      |L5.78|
000042  2e02              CMP      r6,#2                 ;761
000044  d005              BEQ      |L5.82|
000046  2e03              CMP      r6,#3                 ;761
000048  d106              BNE      |L5.88|
00004a  e001              B        |L5.80|
                  |L5.76|
00004c  bf00              NOP                            ;763
                  |L5.78|
00004e  bf00              NOP                            ;764
                  |L5.80|
000050  bf00              NOP                            ;765
                  |L5.82|
000052  2000              MOVS     r0,#0                 ;766
000054  8020              STRH     r0,[r4,#0]            ;766
000056  e003              B        |L5.96|
                  |L5.88|
000058  f2473041          MOV      r0,#0x7341            ;770
00005c  8020              STRH     r0,[r4,#0]            ;770
00005e  bf00              NOP                            ;771
                  |L5.96|
000060  bf00              NOP                            ;767
000062  f7fffffe          BL       OS_TmrUnlock
000066  4630              MOV      r0,r6                 ;776
000068  e7d4              B        |L5.20|
;;;778    
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      OSIntNestingCtr
                  |L5.112|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;819    
;;;820    CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;821                            OS_OPT   opt,
;;;822                            void    *p_callback_arg,
;;;823                            OS_ERR  *p_err)
;;;824    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;825        OS_TMR_CALLBACK_PTR  p_fnct;
;;;826        CPU_BOOLEAN          success;
;;;827    
;;;828    
;;;829    
;;;830    #ifdef OS_SAFETY_CRITICAL
;;;831        if (p_err == DEF_NULL) {
;;;832            OS_SAFETY_CRITICAL_EXCEPTION();
;;;833            return (DEF_FALSE);
;;;834        }
;;;835    #endif
;;;836    
;;;837    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;838        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
00000c  4836              LDR      r0,|L6.232|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  b128              CBZ      r0,|L6.30|
;;;839           *p_err = OS_ERR_TMR_ISR;
000012  f2473043          MOV      r0,#0x7343
000016  8020              STRH     r0,[r4,#0]
;;;840            return (DEF_FALSE);
000018  2000              MOVS     r0,#0
                  |L6.26|
;;;841        }
;;;842    #endif
;;;843    
;;;844    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;845        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;846           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;847            return (DEF_FALSE);
;;;848        }
;;;849    #endif
;;;850    
;;;851    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;852        if (p_tmr == DEF_NULL) {
;;;853           *p_err = OS_ERR_TMR_INVALID;
;;;854            return (DEF_FALSE);
;;;855        }
;;;856    #endif
;;;857    
;;;858    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;859        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;860           *p_err = OS_ERR_OBJ_TYPE;
;;;861            return (DEF_FALSE);
;;;862        }
;;;863    #endif
;;;864    
;;;865        OS_TmrLock();
;;;866    
;;;867        switch (p_tmr->State) {
;;;868            case OS_TMR_STATE_RUNNING:
;;;869                *p_err = OS_ERR_NONE;
;;;870                 switch (opt) {
;;;871                     case OS_OPT_TMR_CALLBACK:
;;;872                          OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
;;;873                          p_fnct = p_tmr->CallbackPtr;              /* Execute callback function ...                        */
;;;874                          if (p_fnct != DEF_NULL) {                 /* ... if available                                     */
;;;875                            (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg); /* Use callback arg when timer was created     */
;;;876                          } else {
;;;877                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;878                          }
;;;879                          break;
;;;880    
;;;881                     case OS_OPT_TMR_CALLBACK_ARG:
;;;882                          OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
;;;883                          p_fnct = p_tmr->CallbackPtr;              /* Execute callback function if available ...           */
;;;884                          if (p_fnct != DEF_NULL) {
;;;885                            (*p_fnct)((void *)p_tmr, p_callback_arg); /* .. using the 'callback_arg' provided in call       */
;;;886                          } else {
;;;887                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;888                          }
;;;889                          break;
;;;890    
;;;891                     case OS_OPT_TMR_NONE:
;;;892                          OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
;;;893                          break;
;;;894    
;;;895                     default:
;;;896                         OS_TmrUnlock();
;;;897                        *p_err = OS_ERR_OPT_INVALID;
;;;898                         return (DEF_FALSE);
;;;899                 }
;;;900                 success = DEF_TRUE;
;;;901                 break;
;;;902    
;;;903            case OS_TMR_STATE_COMPLETED:                            /* Timer has already completed the ONE-SHOT or          */
;;;904            case OS_TMR_STATE_STOPPED:                              /* ... timer has not started yet.                       */
;;;905                *p_err   = OS_ERR_TMR_STOPPED;
;;;906                 success = DEF_TRUE;
;;;907                 break;
;;;908    
;;;909            case OS_TMR_STATE_UNUSED:                               /* Timer was not created                                */
;;;910                *p_err   = OS_ERR_TMR_INACTIVE;
;;;911                 success = DEF_FALSE;
;;;912                 break;
;;;913    
;;;914            default:
;;;915                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;916                 success = DEF_FALSE;
;;;917                 break;
;;;918        }
;;;919    
;;;920        OS_TmrUnlock();
;;;921    
;;;922        return (success);
;;;923    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L6.30|
00001e  b925              CBNZ     r5,|L6.42|
000020  f2473042          MOV      r0,#0x7342            ;853
000024  8020              STRH     r0,[r4,#0]            ;853
000026  2000              MOVS     r0,#0                 ;854
000028  e7f7              B        |L6.26|
                  |L6.42|
00002a  4930              LDR      r1,|L6.236|
00002c  6828              LDR      r0,[r5,#0]            ;859
00002e  4288              CMP      r0,r1                 ;859
000030  d004              BEQ      |L6.60|
000032  f64550c4          MOV      r0,#0x5dc4            ;860
000036  8020              STRH     r0,[r4,#0]            ;860
000038  2000              MOVS     r0,#0                 ;861
00003a  e7ee              B        |L6.26|
                  |L6.60|
00003c  f7fffffe          BL       OS_TmrLock
000040  f8950026          LDRB     r0,[r5,#0x26]         ;867
000044  2800              CMP      r0,#0                 ;867
000046  d040              BEQ      |L6.202|
000048  2801              CMP      r0,#1                 ;867
00004a  d039              BEQ      |L6.192|
00004c  2802              CMP      r0,#2                 ;867
00004e  d002              BEQ      |L6.86|
000050  2803              CMP      r0,#3                 ;867
000052  d13f              BNE      |L6.212|
000054  e033              B        |L6.190|
                  |L6.86|
000056  2000              MOVS     r0,#0                 ;869
000058  8020              STRH     r0,[r4,#0]            ;869
00005a  f1b80f00          CMP      r8,#0                 ;870
00005e  d020              BEQ      |L6.162|
000060  f1b80f03          CMP      r8,#3                 ;870
000064  d003              BEQ      |L6.110|
000066  f1b80f04          CMP      r8,#4                 ;870
00006a  d11e              BNE      |L6.170|
00006c  e00c              B        |L6.136|
                  |L6.110|
00006e  4628              MOV      r0,r5                 ;872
000070  f7fffffe          BL       OS_TmrUnlink
000074  68ae              LDR      r6,[r5,#8]            ;873
000076  b11e              CBZ      r6,|L6.128|
000078  4628              MOV      r0,r5                 ;875
00007a  68e9              LDR      r1,[r5,#0xc]          ;875
00007c  47b0              BLX      r6                    ;875
00007e  e002              B        |L6.134|
                  |L6.128|
000080  f2473044          MOV      r0,#0x7344            ;877
000084  8020              STRH     r0,[r4,#0]            ;877
                  |L6.134|
000086  e017              B        |L6.184|
                  |L6.136|
000088  4628              MOV      r0,r5                 ;882
00008a  f7fffffe          BL       OS_TmrUnlink
00008e  68ae              LDR      r6,[r5,#8]            ;883
000090  b11e              CBZ      r6,|L6.154|
000092  4649              MOV      r1,r9                 ;885
000094  4628              MOV      r0,r5                 ;885
000096  47b0              BLX      r6                    ;885
000098  e002              B        |L6.160|
                  |L6.154|
00009a  f2473044          MOV      r0,#0x7344            ;887
00009e  8020              STRH     r0,[r4,#0]            ;887
                  |L6.160|
0000a0  e00a              B        |L6.184|
                  |L6.162|
0000a2  4628              MOV      r0,r5                 ;892
0000a4  f7fffffe          BL       OS_TmrUnlink
0000a8  e006              B        |L6.184|
                  |L6.170|
0000aa  f7fffffe          BL       OS_TmrUnlock
0000ae  f6456025          MOV      r0,#0x5e25            ;897
0000b2  8020              STRH     r0,[r4,#0]            ;897
0000b4  2000              MOVS     r0,#0                 ;898
0000b6  e7b0              B        |L6.26|
                  |L6.184|
0000b8  bf00              NOP                            ;879
0000ba  2701              MOVS     r7,#1                 ;900
0000bc  e00f              B        |L6.222|
                  |L6.190|
0000be  bf00              NOP                            ;904
                  |L6.192|
0000c0  f2473049          MOV      r0,#0x7349            ;905
0000c4  8020              STRH     r0,[r4,#0]            ;905
0000c6  2701              MOVS     r7,#1                 ;906
0000c8  e009              B        |L6.222|
                  |L6.202|
0000ca  f247303d          MOV      r0,#0x733d            ;910
0000ce  8020              STRH     r0,[r4,#0]            ;910
0000d0  2700              MOVS     r7,#0                 ;911
0000d2  e004              B        |L6.222|
                  |L6.212|
0000d4  f2473041          MOV      r0,#0x7341            ;915
0000d8  8020              STRH     r0,[r4,#0]            ;915
0000da  2700              MOVS     r7,#0                 ;916
0000dc  bf00              NOP                            ;917
                  |L6.222|
0000de  bf00              NOP                            ;901
0000e0  f7fffffe          BL       OS_TmrUnlock
0000e4  4638              MOV      r0,r7                 ;922
0000e6  e798              B        |L6.26|
;;;924    
                          ENDP

                  |L6.232|
                          DCD      OSIntNestingCtr
                  |L6.236|
                          DCD      0x20524d54

                          AREA ||i.OS_TmrClr||, CODE, READONLY, ALIGN=2

                  OS_TmrClr PROC
;;;940    
;;;941    void  OS_TmrClr (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;942    {
;;;943        p_tmr->State          = OS_TMR_STATE_UNUSED;                /* Clear timer fields                                   */
000002  f8801026          STRB     r1,[r0,#0x26]
;;;944    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;945        p_tmr->Type           = OS_OBJ_TYPE_NONE;
000006  4907              LDR      r1,|L7.36|
000008  6001              STR      r1,[r0,#0]
;;;946    #endif
;;;947    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;948        p_tmr->NamePtr        = (CPU_CHAR *)((void *)"?TMR");
00000a  a107              ADR      r1,|L7.40|
00000c  6041              STR      r1,[r0,#4]
;;;949    #endif
;;;950        p_tmr->Dly            = 0u;
00000e  2100              MOVS     r1,#0
000010  61c1              STR      r1,[r0,#0x1c]
;;;951        p_tmr->Remain         = 0u;
000012  6181              STR      r1,[r0,#0x18]
;;;952        p_tmr->Period         = 0u;
000014  6201              STR      r1,[r0,#0x20]
;;;953        p_tmr->Opt            = 0u;
000016  8481              STRH     r1,[r0,#0x24]
;;;954        p_tmr->CallbackPtr    = DEF_NULL;
000018  6081              STR      r1,[r0,#8]
;;;955        p_tmr->CallbackPtrArg = DEF_NULL;
00001a  60c1              STR      r1,[r0,#0xc]
;;;956        p_tmr->NextPtr        = DEF_NULL;
00001c  6101              STR      r1,[r0,#0x10]
;;;957        p_tmr->PrevPtr        = DEF_NULL;
00001e  6141              STR      r1,[r0,#0x14]
;;;958    }
000020  4770              BX       lr
;;;959    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x454e4f4e
                  |L7.40|
000028  3f544d52          DCB      "?TMR",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.OS_TmrDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListAdd PROC
;;;976    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;977    void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;978    {
;;;979        p_tmr->DbgPrevPtr               = DEF_NULL;
000002  6281              STR      r1,[r0,#0x28]
;;;980        if (OSTmrDbgListPtr == DEF_NULL) {
000004  4907              LDR      r1,|L8.36|
000006  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000008  b911              CBNZ     r1,|L8.16|
;;;981            p_tmr->DbgNextPtr           = DEF_NULL;
00000a  2100              MOVS     r1,#0
00000c  62c1              STR      r1,[r0,#0x2c]
00000e  e005              B        |L8.28|
                  |L8.16|
;;;982        } else {
;;;983            p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
000010  4904              LDR      r1,|L8.36|
000012  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000014  62c1              STR      r1,[r0,#0x2c]
;;;984            OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
000016  4903              LDR      r1,|L8.36|
000018  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
00001a  6288              STR      r0,[r1,#0x28]
                  |L8.28|
;;;985        }
;;;986        OSTmrDbgListPtr                 =  p_tmr;
00001c  4901              LDR      r1,|L8.36|
00001e  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;987    }
000020  4770              BX       lr
;;;988    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListRemove PROC
;;;990    
;;;991    void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
000000  6a82              LDR      r2,[r0,#0x28]
;;;992    {
;;;993        OS_TMR  *p_tmr_next;
;;;994        OS_TMR  *p_tmr_prev;
;;;995    
;;;996    
;;;997        p_tmr_prev = p_tmr->DbgPrevPtr;
;;;998        p_tmr_next = p_tmr->DbgNextPtr;
000002  6ac1              LDR      r1,[r0,#0x2c]
;;;999    
;;;1000       if (p_tmr_prev == DEF_NULL) {
000004  b93a              CBNZ     r2,|L9.22|
;;;1001           OSTmrDbgListPtr = p_tmr_next;
000006  4b09              LDR      r3,|L9.44|
000008  6019              STR      r1,[r3,#0]  ; OSTmrDbgListPtr
;;;1002           if (p_tmr_next != DEF_NULL) {
00000a  b109              CBZ      r1,|L9.16|
;;;1003               p_tmr_next->DbgPrevPtr = DEF_NULL;
00000c  2300              MOVS     r3,#0
00000e  628b              STR      r3,[r1,#0x28]
                  |L9.16|
;;;1004           }
;;;1005           p_tmr->DbgNextPtr = DEF_NULL;
000010  2300              MOVS     r3,#0
000012  62c3              STR      r3,[r0,#0x2c]
000014  e009              B        |L9.42|
                  |L9.22|
;;;1006   
;;;1007       } else if (p_tmr_next == DEF_NULL) {
000016  b919              CBNZ     r1,|L9.32|
;;;1008           p_tmr_prev->DbgNextPtr = DEF_NULL;
000018  2300              MOVS     r3,#0
00001a  62d3              STR      r3,[r2,#0x2c]
;;;1009           p_tmr->DbgPrevPtr      = DEF_NULL;
00001c  6283              STR      r3,[r0,#0x28]
00001e  e004              B        |L9.42|
                  |L9.32|
;;;1010   
;;;1011       } else {
;;;1012           p_tmr_prev->DbgNextPtr = p_tmr_next;
000020  62d1              STR      r1,[r2,#0x2c]
;;;1013           p_tmr_next->DbgPrevPtr = p_tmr_prev;
000022  628a              STR      r2,[r1,#0x28]
;;;1014           p_tmr->DbgNextPtr      = DEF_NULL;
000024  2300              MOVS     r3,#0
000026  62c3              STR      r3,[r0,#0x2c]
;;;1015           p_tmr->DbgPrevPtr      = DEF_NULL;
000028  6283              STR      r3,[r0,#0x28]
                  |L9.42|
;;;1016       }
;;;1017   }
00002a  4770              BX       lr
;;;1018   #endif
                          ENDP

                  |L9.44|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrInit||, CODE, READONLY, ALIGN=2

                  OS_TmrInit PROC
;;;1040   
;;;1041   void  OS_TmrInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;1042   {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;1043   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1044       OSTmrDbgListPtr = DEF_NULL;
000006  2000              MOVS     r0,#0
000008  492f              LDR      r1,|L10.200|
00000a  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;1045   #endif
;;;1046   
;;;1047       OSTmrListPtr        = DEF_NULL;                             /* Create an empty timer list                           */
00000c  492f              LDR      r1,|L10.204|
00000e  6008              STR      r0,[r1,#0]  ; OSTmrListPtr
;;;1048   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1049       OSTmrListEntries    = 0u;
000010  492f              LDR      r1,|L10.208|
000012  8008              STRH     r0,[r1,#0]
;;;1050   #endif
;;;1051   
;;;1052       if (OSCfg_TmrTaskRate_Hz > 0u) {
000014  482f              LDR      r0,|L10.212|
000016  6800              LDR      r0,[r0,#0]  ; OSCfg_TmrTaskRate_Hz
000018  b140              CBZ      r0,|L10.44|
;;;1053           OSTmrUpdateCnt  = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
00001a  482f              LDR      r0,|L10.216|
00001c  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
00001e  492d              LDR      r1,|L10.212|
000020  6809              LDR      r1,[r1,#0]  ; OSCfg_TmrTaskRate_Hz
000022  fbb0f0f1          UDIV     r0,r0,r1
000026  492d              LDR      r1,|L10.220|
000028  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
00002a  e006              B        |L10.58|
                  |L10.44|
;;;1054       } else {
;;;1055           OSTmrUpdateCnt  = OSCfg_TickRate_Hz / 10u;
00002c  482a              LDR      r0,|L10.216|
00002e  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000030  210a              MOVS     r1,#0xa
000032  fbb0f0f1          UDIV     r0,r0,r1
000036  4929              LDR      r1,|L10.220|
000038  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
                  |L10.58|
;;;1056       }
;;;1057       OSTmrUpdateCtr      = OSTmrUpdateCnt;
00003a  4828              LDR      r0,|L10.220|
00003c  6800              LDR      r0,[r0,#0]  ; OSTmrUpdateCnt
00003e  4928              LDR      r1,|L10.224|
000040  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCtr
;;;1058   
;;;1059       OSTmrTickCtr        = 0u;
000042  2000              MOVS     r0,#0
000044  4927              LDR      r1,|L10.228|
000046  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;1060   
;;;1061   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1062       OSTmrTaskTimeMax    = 0u;
000048  4927              LDR      r1,|L10.232|
00004a  6008              STR      r0,[r1,#0]  ; OSTmrTaskTimeMax
;;;1063   #endif
;;;1064   
;;;1065   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;1066       OSMutexCreate(&OSTmrMutex,                                  /* Use a mutex to protect the timers                    */
00004c  4622              MOV      r2,r4
00004e  a127              ADR      r1,|L10.236|
000050  482a              LDR      r0,|L10.252|
000052  f7fffffe          BL       OSMutexCreate
;;;1067                     (CPU_CHAR *)"OS Tmr Mutex", 
;;;1068                     p_err);
;;;1069       if (*p_err != OS_ERR_NONE) {
000056  8820              LDRH     r0,[r4,#0]
000058  b108              CBZ      r0,|L10.94|
                  |L10.90|
;;;1070           return;
;;;1071       }
;;;1072   #endif
;;;1073   
;;;1074                                                                   /* -------------- CREATE THE TIMER TASK --------------- */
;;;1075       if (OSCfg_TmrTaskStkBasePtr == DEF_NULL) {
;;;1076          *p_err = OS_ERR_TMR_STK_INVALID;
;;;1077           return;
;;;1078       }
;;;1079   
;;;1080       if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
;;;1081          *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
;;;1082           return;
;;;1083       }
;;;1084   
;;;1085       if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
;;;1086          *p_err = OS_ERR_TMR_PRIO_INVALID;
;;;1087           return;
;;;1088       }
;;;1089   
;;;1090       OSTaskCreate(&OSTmrTaskTCB,
;;;1091                    (CPU_CHAR   *)((void *)"uC/OS-III Timer Task"),
;;;1092                    OS_TmrTask,
;;;1093                    DEF_NULL,
;;;1094                    OSCfg_TmrTaskPrio,
;;;1095                    OSCfg_TmrTaskStkBasePtr,
;;;1096                    OSCfg_TmrTaskStkLimit,
;;;1097                    OSCfg_TmrTaskStkSize,
;;;1098                    0u,
;;;1099                    0u,
;;;1100                    DEF_NULL,
;;;1101                    (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;1102                    p_err);
;;;1103   }
00005a  b00a              ADD      sp,sp,#0x28
00005c  bd10              POP      {r4,pc}
                  |L10.94|
00005e  4828              LDR      r0,|L10.256|
000060  6800              LDR      r0,[r0,#0]            ;1075  ; OSCfg_TmrTaskStkBasePtr
000062  b918              CBNZ     r0,|L10.108|
000064  f2473047          MOV      r0,#0x7347            ;1076
000068  8020              STRH     r0,[r4,#0]            ;1076
00006a  e7f6              B        |L10.90|
                  |L10.108|
00006c  4825              LDR      r0,|L10.260|
00006e  6800              LDR      r0,[r0,#0]            ;1080  ; OSCfg_TmrTaskStkSize
000070  4925              LDR      r1,|L10.264|
000072  6809              LDR      r1,[r1,#0]            ;1080  ; OSCfg_StkSizeMin
000074  4288              CMP      r0,r1                 ;1080
000076  d203              BCS      |L10.128|
000078  f2473048          MOV      r0,#0x7348            ;1081
00007c  8020              STRH     r0,[r4,#0]            ;1081
00007e  e7ec              B        |L10.90|
                  |L10.128|
000080  4822              LDR      r0,|L10.268|
000082  7800              LDRB     r0,[r0,#0]            ;1085  ; OSCfg_TmrTaskPrio
000084  281f              CMP      r0,#0x1f              ;1085
000086  d303              BCC      |L10.144|
000088  f2473046          MOV      r0,#0x7346            ;1086
00008c  8020              STRH     r0,[r4,#0]            ;1086
00008e  e7e4              B        |L10.90|
                  |L10.144|
000090  200b              MOVS     r0,#0xb               ;1090
000092  2100              MOVS     r1,#0                 ;1090
000094  9105              STR      r1,[sp,#0x14]         ;1090
000096  460a              MOV      r2,r1                 ;1090
000098  e9cd0407          STRD     r0,r4,[sp,#0x1c]      ;1090
00009c  9106              STR      r1,[sp,#0x18]         ;1090
00009e  4819              LDR      r0,|L10.260|
0000a0  6800              LDR      r0,[r0,#0]            ;1090  ; OSCfg_TmrTaskStkSize
0000a2  491b              LDR      r1,|L10.272|
0000a4  6809              LDR      r1,[r1,#0]            ;1090  ; OSCfg_TmrTaskStkLimit
0000a6  4b16              LDR      r3,|L10.256|
0000a8  681b              LDR      r3,[r3,#0]            ;1090  ; OSCfg_TmrTaskStkBasePtr
0000aa  e9cd3101          STRD     r3,r1,[sp,#4]         ;1090
0000ae  e9cd0203          STRD     r0,r2,[sp,#0xc]       ;1090
0000b2  4816              LDR      r0,|L10.268|
0000b4  7800              LDRB     r0,[r0,#0]            ;1090  ; OSCfg_TmrTaskPrio
0000b6  2300              MOVS     r3,#0                 ;1090
0000b8  4a16              LDR      r2,|L10.276|
0000ba  a117              ADR      r1,|L10.280|
0000bc  9000              STR      r0,[sp,#0]            ;1090
0000be  481c              LDR      r0,|L10.304|
0000c0  f7fffffe          BL       OSTaskCreate
0000c4  bf00              NOP      
0000c6  e7c8              B        |L10.90|
;;;1104   
                          ENDP

                  |L10.200|
                          DCD      OSTmrDbgListPtr
                  |L10.204|
                          DCD      OSTmrListPtr
                  |L10.208|
                          DCD      OSTmrListEntries
                  |L10.212|
                          DCD      OSCfg_TmrTaskRate_Hz
                  |L10.216|
                          DCD      OSCfg_TickRate_Hz
                  |L10.220|
                          DCD      OSTmrUpdateCnt
                  |L10.224|
                          DCD      OSTmrUpdateCtr
                  |L10.228|
                          DCD      OSTmrTickCtr
                  |L10.232|
                          DCD      OSTmrTaskTimeMax
                  |L10.236|
0000ec  4f532054          DCB      "OS Tmr Mutex",0
0000f0  6d72204d
0000f4  75746578
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L10.252|
                          DCD      OSTmrMutex
                  |L10.256|
                          DCD      OSCfg_TmrTaskStkBasePtr
                  |L10.260|
                          DCD      OSCfg_TmrTaskStkSize
                  |L10.264|
                          DCD      OSCfg_StkSizeMin
                  |L10.268|
                          DCD      OSCfg_TmrTaskPrio
                  |L10.272|
                          DCD      OSCfg_TmrTaskStkLimit
                  |L10.276|
                          DCD      OS_TmrTask
                  |L10.280|
000118  75432f4f          DCB      "uC/OS-III Timer Task",0
00011c  532d4949
000120  49205469
000124  6d657220
000128  5461736b
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0
                  |L10.304|
                          DCD      OSTmrTaskTCB

                          AREA ||i.OS_TmrLock||, CODE, READONLY, ALIGN=2

                  OS_TmrLock PROC
;;;1248   
;;;1249   static  void  OS_TmrLock (void)
000000  b50e              PUSH     {r1-r3,lr}
;;;1250   {
;;;1251       OS_ERR  err;
;;;1252   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;1253       CPU_TS  ts;
;;;1254   
;;;1255   
;;;1256       OSMutexPend(&OSTmrMutex,                                    /* Use a mutex to protect the timers                    */
000002  a802              ADD      r0,sp,#8
000004  ab01              ADD      r3,sp,#4
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  9000              STR      r0,[sp,#0]
00000c  4801              LDR      r0,|L11.20|
00000e  f7fffffe          BL       OSMutexPend
;;;1257                   0u,
;;;1258                   OS_OPT_PEND_BLOCKING,
;;;1259                   &ts,
;;;1260                   &err);
;;;1261   #else
;;;1262       OSSchedLock(&err);                                          /* Lock the scheduler to protect the timers             */
;;;1263   #endif
;;;1264       (void)&err;
;;;1265   }
000012  bd0e              POP      {r1-r3,pc}
;;;1266   
                          ENDP

                  |L11.20|
                          DCD      OSTmrMutex

                          AREA ||i.OS_TmrTask||, CODE, READONLY, ALIGN=2

                  OS_TmrTask PROC
;;;1163   
;;;1164   void  OS_TmrTask (void  *p_arg)
000000  b51c              PUSH     {r2-r4,lr}
;;;1165   {
;;;1166       OS_ERR               err;
;;;1167       OS_TMR_CALLBACK_PTR  p_fnct;
;;;1168       OS_TMR              *p_tmr;
;;;1169       OS_TMR              *p_tmr_next;
;;;1170       CPU_TS               ts;
;;;1171   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1172       CPU_TS               ts_start;
;;;1173       CPU_TS               ts_delta;
;;;1174   #endif
;;;1175   
;;;1176   
;;;1177   
;;;1178       (void)p_arg;                                                /* Not using 'p_arg', prevent compiler warning          */
;;;1179       while (DEF_ON) {
000002  e03f              B        |L12.132|
                  |L12.4|
;;;1180   #if (OS_CFG_DYN_TICK_EN != DEF_ENABLED)
;;;1181           (void)OSTaskSemPend( 0u,                                /* Wait for signal indicating time to update tmrs       */
000004  ab01              ADD      r3,sp,#4
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       OSTaskSemPend
;;;1182                                OS_OPT_PEND_BLOCKING,
;;;1183                               &ts,
;;;1184                               &err);
;;;1185           (void)err;
;;;1186   #else
;;;1187           OSTimeDly(OSTmrUpdateCnt, OS_OPT_TIME_DLY, &err);
;;;1188           (void)err;
;;;1189   #endif
;;;1190   
;;;1191   
;;;1192           OS_TmrLock();
000010  f7fffffe          BL       OS_TmrLock
;;;1193   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1194           ts_start = OS_TS_GET();
000014  f7fffffe          BL       CPU_TS_TmrRd
000018  4606              MOV      r6,r0
;;;1195   #endif
;;;1196           OSTmrTickCtr++;                                         /* Increment the current time                           */
00001a  481b              LDR      r0,|L12.136|
00001c  6800              LDR      r0,[r0,#0]  ; OSTmrTickCtr
00001e  1c40              ADDS     r0,r0,#1
000020  4919              LDR      r1,|L12.136|
000022  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;1197           p_tmr    = OSTmrListPtr;
000024  4819              LDR      r0,|L12.140|
000026  6804              LDR      r4,[r0,#0]  ; OSTmrListPtr
;;;1198           while (p_tmr != DEF_NULL) {                             /* Update all the timers in the list                    */
000028  e01f              B        |L12.106|
                  |L12.42|
;;;1199               OSSchedLock(&err);
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       OSSchedLock
;;;1200               (void)&err;
;;;1201               p_tmr_next = p_tmr->NextPtr;
000030  f8d48010          LDR      r8,[r4,#0x10]
;;;1202               p_tmr->Remain--;
000034  69a0              LDR      r0,[r4,#0x18]
000036  1e40              SUBS     r0,r0,#1
000038  61a0              STR      r0,[r4,#0x18]
;;;1203               if (p_tmr->Remain == 0u) {
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  b980              CBNZ     r0,|L12.96|
;;;1204                   if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
00003e  8ca0              LDRH     r0,[r4,#0x24]
000040  2802              CMP      r0,#2
000042  d102              BNE      |L12.74|
;;;1205                       p_tmr->Remain = p_tmr->Period;              /* Reload the time remaining                            */
000044  6a20              LDR      r0,[r4,#0x20]
000046  61a0              STR      r0,[r4,#0x18]
000048  e005              B        |L12.86|
                  |L12.74|
;;;1206                   } else {
;;;1207                       OS_TmrUnlink(p_tmr);                        /* Remove from list                                     */
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_TmrUnlink
;;;1208                       p_tmr->State = OS_TMR_STATE_COMPLETED;      /* Indicate that the timer has completed                */
000050  2003              MOVS     r0,#3
000052  f8840026          STRB     r0,[r4,#0x26]
                  |L12.86|
;;;1209                   }
;;;1210                   p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available               */
000056  68a5              LDR      r5,[r4,#8]
;;;1211                   if (p_fnct != 0u) {
000058  b115              CBZ      r5,|L12.96|
;;;1212                       (*p_fnct)((void *)p_tmr,
00005a  4620              MOV      r0,r4
00005c  68e1              LDR      r1,[r4,#0xc]
00005e  47a8              BLX      r5
                  |L12.96|
;;;1213                                 p_tmr->CallbackPtrArg);
;;;1214                   }
;;;1215               }
;;;1216               p_tmr = p_tmr_next;
000060  4644              MOV      r4,r8
;;;1217               OSSchedUnlock(&err);
000062  a801              ADD      r0,sp,#4
000064  f7fffffe          BL       OSSchedUnlock
;;;1218               (void)&err;
000068  bf00              NOP      
                  |L12.106|
00006a  2c00              CMP      r4,#0                 ;1198
00006c  d1dd              BNE      |L12.42|
;;;1219           }
;;;1220   
;;;1221   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1222           ts_delta = OS_TS_GET() - ts_start;                      /* Measure execution time of timer task                 */
00006e  f7fffffe          BL       CPU_TS_TmrRd
000072  1b87              SUBS     r7,r0,r6
;;;1223           if (OSTmrTaskTimeMax < ts_delta) {
000074  4806              LDR      r0,|L12.144|
000076  6800              LDR      r0,[r0,#0]  ; OSTmrTaskTimeMax
000078  42b8              CMP      r0,r7
00007a  d201              BCS      |L12.128|
;;;1224               OSTmrTaskTimeMax = ts_delta;
00007c  4804              LDR      r0,|L12.144|
00007e  6007              STR      r7,[r0,#0]  ; OSTmrTaskTimeMax
                  |L12.128|
;;;1225           }
;;;1226   #endif
;;;1227   
;;;1228           OS_TmrUnlock();
000080  f7fffffe          BL       OS_TmrUnlock
                  |L12.132|
000084  e7be              B        |L12.4|
;;;1229       }
;;;1230   }
;;;1231   
                          ENDP

000086  0000              DCW      0x0000
                  |L12.136|
                          DCD      OSTmrTickCtr
                  |L12.140|
                          DCD      OSTmrListPtr
                  |L12.144|
                          DCD      OSTmrTaskTimeMax

                          AREA ||i.OS_TmrUnlink||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlink PROC
;;;1120   
;;;1121   void  OS_TmrUnlink (OS_TMR  *p_tmr)
000000  b510              PUSH     {r4,lr}
;;;1122   {
;;;1123       OS_TMR  *p_tmr1;
;;;1124       OS_TMR  *p_tmr2;
;;;1125   
;;;1126   
;;;1127       if (OSTmrListPtr == p_tmr) {                                /* See if timer to remove is at the beginning of list   */
000002  4b0e              LDR      r3,|L13.60|
000004  681b              LDR      r3,[r3,#0]  ; OSTmrListPtr
000006  4283              CMP      r3,r0
000008  d106              BNE      |L13.24|
;;;1128           p_tmr1       = p_tmr->NextPtr;
00000a  6901              LDR      r1,[r0,#0x10]
;;;1129           OSTmrListPtr = p_tmr1;
00000c  4b0b              LDR      r3,|L13.60|
00000e  6019              STR      r1,[r3,#0]  ; OSTmrListPtr
;;;1130           if (p_tmr1 != DEF_NULL) {
000010  b139              CBZ      r1,|L13.34|
;;;1131               p_tmr1->PrevPtr = DEF_NULL;
000012  2300              MOVS     r3,#0
000014  614b              STR      r3,[r1,#0x14]
000016  e004              B        |L13.34|
                  |L13.24|
;;;1132           }
;;;1133       } else {
;;;1134           p_tmr1          = p_tmr->PrevPtr;                       /* Remove timer from somewhere in the list              */
000018  6941              LDR      r1,[r0,#0x14]
;;;1135           p_tmr2          = p_tmr->NextPtr;
00001a  6902              LDR      r2,[r0,#0x10]
;;;1136           p_tmr1->NextPtr = p_tmr2;
00001c  610a              STR      r2,[r1,#0x10]
;;;1137           if (p_tmr2 != DEF_NULL) {
00001e  b102              CBZ      r2,|L13.34|
;;;1138               p_tmr2->PrevPtr = p_tmr1;
000020  6151              STR      r1,[r2,#0x14]
                  |L13.34|
;;;1139           }
;;;1140       }
;;;1141       p_tmr->State   = OS_TMR_STATE_STOPPED;
000022  2301              MOVS     r3,#1
000024  f8803026          STRB     r3,[r0,#0x26]
;;;1142       p_tmr->NextPtr = DEF_NULL;
000028  2300              MOVS     r3,#0
00002a  6103              STR      r3,[r0,#0x10]
;;;1143       p_tmr->PrevPtr = DEF_NULL;
00002c  6143              STR      r3,[r0,#0x14]
;;;1144   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1145       OSTmrListEntries--;
00002e  4b04              LDR      r3,|L13.64|
000030  881b              LDRH     r3,[r3,#0]  ; OSTmrListEntries
000032  1e5b              SUBS     r3,r3,#1
000034  4c02              LDR      r4,|L13.64|
000036  8023              STRH     r3,[r4,#0]
;;;1146   #endif
;;;1147   }
000038  bd10              POP      {r4,pc}
;;;1148   
                          ENDP

00003a  0000              DCW      0x0000
                  |L13.60|
                          DCD      OSTmrListPtr
                  |L13.64|
                          DCD      OSTmrListEntries

                          AREA ||i.OS_TmrUnlock||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlock PROC
;;;1269   
;;;1270   static  void  OS_TmrUnlock (void)
000000  b508              PUSH     {r3,lr}
;;;1271   {
;;;1272       OS_ERR  err;
;;;1273   
;;;1274   
;;;1275   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;1276       OSMutexPost(&OSTmrMutex,                                    /* Use a mutex to protect the timers                    */
000002  466a              MOV      r2,sp
000004  2100              MOVS     r1,#0
000006  4802              LDR      r0,|L14.16|
000008  f7fffffe          BL       OSMutexPost
;;;1277                   OS_OPT_POST_NONE,
;;;1278                   &err);
;;;1279   #else
;;;1280       OSSchedUnlock(&err);                                        /* Lock the scheduler to protect the timers             */
;;;1281   #endif
;;;1282       (void)&err;
;;;1283   }
00000c  bd08              POP      {r3,pc}
;;;1284   
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      OSTmrMutex
