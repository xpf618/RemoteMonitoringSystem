; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_flag.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_flag.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -IH:\½øÐÐÊ±\CS_System_Program\Project\MDK-ARM(uV4)\RTE -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\os_flag.crf ..\..\uCOS-III\uCOS-III\Source\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;68     
;;;69     void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70                         CPU_CHAR     *p_name,
;;;71                         OS_FLAGS      flags,
;;;72                         OS_ERR       *p_err)
;;;73     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;74         CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;75     
;;;76     
;;;77     
;;;78     #ifdef OS_SAFETY_CRITICAL
;;;79         if (p_err == DEF_NULL) {
;;;80             OS_SAFETY_CRITICAL_EXCEPTION();
;;;81             return;
;;;82         }
;;;83     #endif
;;;84     
;;;85     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;86         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;87            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;88             return;
;;;89         }
;;;90     #endif
;;;91     
;;;92     #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;93         if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
000010  481a              LDR      r0,|L1.124|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  b120              CBZ      r0,|L1.32|
;;;94            *p_err = OS_ERR_CREATE_ISR;                              /* ... can't CREATE from an ISR                         */
000016  f64260e1          MOV      r0,#0x2ee1
00001a  8028              STRH     r0,[r5,#0]
                  |L1.28|
;;;95             return;
;;;96         }
;;;97     #endif
;;;98     
;;;99     #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;100        if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
;;;101           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;102            return;
;;;103        }
;;;104    #endif
;;;105    
;;;106        OS_CRITICAL_ENTER();
;;;107    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;108        p_grp->Type    = OS_OBJ_TYPE_FLAG;                          /* Set to event flag group type                         */
;;;109    #endif
;;;110    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;111        p_grp->NamePtr = p_name;
;;;112    #else
;;;113        (void)&p_name;
;;;114    #endif
;;;115        p_grp->Flags   = flags;                                     /* Set to desired initial value                         */
;;;116    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;117        p_grp->TS      = 0u;
;;;118    #endif
;;;119        OS_PendListInit(&p_grp->PendList);
;;;120    
;;;121    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;122        OS_FlagDbgListAdd(p_grp);
;;;123        OSFlagQty++;
;;;124    #endif
;;;125    
;;;126    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;127        TRACE_OS_FLAG_CREATE(p_grp, p_name);                        /* Record the event.                                    */
;;;128    #endif
;;;129        
;;;130        OS_CRITICAL_EXIT_NO_SCHED();
;;;131       *p_err = OS_ERR_NONE;
;;;132    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.32|
000020  b91c              CBNZ     r4,|L1.42|
000022  f64550c3          MOV      r0,#0x5dc3            ;101
000026  8028              STRH     r0,[r5,#0]            ;101
000028  e7f8              B        |L1.28|
                  |L1.42|
00002a  bf00              NOP                            ;106
00002c  bf00              NOP                            ;106
00002e  f7fffffe          BL       CPU_SR_Save
000032  4680              MOV      r8,r0                 ;106
000034  bf00              NOP                            ;106
000036  f7fffffe          BL       CPU_IntDisMeasStart
00003a  bf00              NOP                            ;106
00003c  4810              LDR      r0,|L1.128|
00003e  6020              STR      r0,[r4,#0]            ;108
000040  6067              STR      r7,[r4,#4]            ;111
000042  6226              STR      r6,[r4,#0x20]         ;115
000044  2000              MOVS     r0,#0                 ;117
000046  6260              STR      r0,[r4,#0x24]         ;117
000048  f1040008          ADD      r0,r4,#8              ;119
00004c  f7fffffe          BL       OS_PendListInit
000050  4620              MOV      r0,r4                 ;122
000052  f7fffffe          BL       OS_FlagDbgListAdd
000056  480b              LDR      r0,|L1.132|
000058  8800              LDRH     r0,[r0,#0]            ;123  ; OSFlagQty
00005a  1c40              ADDS     r0,r0,#1              ;123
00005c  4909              LDR      r1,|L1.132|
00005e  8008              STRH     r0,[r1,#0]            ;123
000060  bf00              NOP                            ;130
000062  f7fffffe          BL       CPU_IntDisMeasStop
000066  bf00              NOP                            ;130
000068  4640              MOV      r0,r8                 ;130
00006a  f7fffffe          BL       CPU_SR_Restore
00006e  bf00              NOP                            ;130
000070  bf00              NOP                            ;130
000072  2000              MOVS     r0,#0                 ;131
000074  8028              STRH     r0,[r5,#0]            ;131
000076  bf00              NOP      
000078  e7d0              B        |L1.28|
;;;133    
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      OSIntNestingCtr
                  |L1.128|
                          DCD      0x47414c46
                  |L1.132|
                          DCD      OSFlagQty

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;348    
;;;349    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;350                          OS_FLAGS      flags,
;;;351                          OS_TICK       timeout,
;;;352                          OS_OPT        opt,
;;;353                          CPU_TS       *p_ts,
;;;354                          OS_ERR       *p_err)
;;;355    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4605              MOV      r5,r0
000008  4689              MOV      r9,r1
00000a  4698              MOV      r8,r3
00000c  e9dd6418          LDRD     r6,r4,[sp,#0x60]
;;;356        CPU_BOOLEAN   consume;
;;;357        OS_FLAGS      flags_rdy;
;;;358        OS_OPT        mode;
;;;359        OS_PEND_DATA  pend_data;
;;;360        CPU_SR_ALLOC();
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;361    
;;;362    
;;;363    #ifdef OS_SAFETY_CRITICAL
;;;364        if (p_err == DEF_NULL) {
;;;365            OS_SAFETY_CRITICAL_EXCEPTION();
;;;366            return (0u);
;;;367        }
;;;368    #endif
;;;369    
;;;370    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;371        if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
000014  48e4              LDR      r0,|L2.936|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000018  b130              CBZ      r0,|L2.40|
;;;372    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;373            TRACE_OS_FLAG_PEND_FAILED(p_grp);                       /* Record the event.                                    */
;;;374    #endif
;;;375           *p_err = OS_ERR_PEND_ISR;                                /* ... can't PEND from an ISR                           */
00001a  f24610ae          MOV      r0,#0x61ae
00001e  8020              STRH     r0,[r4,#0]
;;;376            return ((OS_FLAGS)0);
000020  2000              MOVS     r0,#0
                  |L2.34|
;;;377        }
;;;378    #endif
;;;379    
;;;380    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;381        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;382           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;383            return (0u);
;;;384        }
;;;385    #endif
;;;386    
;;;387    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;388        if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
;;;389    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;390            TRACE_OS_FLAG_PEND_FAILED(p_grp);                       /* Record the event.                                    */
;;;391    #endif
;;;392           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;393            return (0u);
;;;394        }
;;;395        switch (opt) {                                              /* Validate 'opt'                                       */
;;;396            case OS_OPT_PEND_FLAG_CLR_ALL:
;;;397            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;398            case OS_OPT_PEND_FLAG_SET_ALL:
;;;399            case OS_OPT_PEND_FLAG_SET_ANY:
;;;400            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;401            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;402            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;403            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;404            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;405            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;406            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;407            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;408            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;409            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;410            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;411            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;412                 break;
;;;413    
;;;414            default:
;;;415    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;416                 TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
;;;417    #endif
;;;418                *p_err = OS_ERR_OPT_INVALID;
;;;419                 return (0u);
;;;420        }
;;;421    #endif
;;;422    
;;;423    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;424        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Validate that we are pointing at an event flag       */
;;;425    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;426            TRACE_OS_FLAG_PEND_FAILED(p_grp);                       /* Record the event.                                    */
;;;427    #endif
;;;428           *p_err = OS_ERR_OBJ_TYPE;
;;;429            return (0u);
;;;430        }
;;;431    #endif
;;;432    
;;;433        if ((opt & OS_OPT_PEND_FLAG_CONSUME) != 0u) {               /* See if we need to consume the flags                  */
;;;434            consume = DEF_TRUE;
;;;435        } else {
;;;436            consume = DEF_FALSE;
;;;437        }
;;;438    
;;;439        if (p_ts != DEF_NULL) {
;;;440           *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
;;;441        }
;;;442    
;;;443        mode = opt & OS_OPT_PEND_FLAG_MASK;
;;;444        CPU_CRITICAL_ENTER();
;;;445        switch (mode) {
;;;446            case OS_OPT_PEND_FLAG_SET_ALL:                          /* See if all required flags are set                    */
;;;447                 flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
;;;448                 if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
;;;449                     if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
;;;450                         p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we wanted                  */
;;;451                     }
;;;452                     OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
;;;453    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;454                     if (p_ts != DEF_NULL) {
;;;455                        *p_ts = p_grp->TS;
;;;456                     }
;;;457    #endif
;;;458                     CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
;;;459    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;460                     TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
;;;461    #endif
;;;462                    *p_err = OS_ERR_NONE;
;;;463                     return (flags_rdy);
;;;464                 } else {                                           /* Block task until events occur or timeout             */
;;;465                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
;;;466                         CPU_CRITICAL_EXIT();
;;;467    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;468                         TRACE_OS_FLAG_PEND_FAILED(p_grp);          /* Record the event.                                    */
;;;469    #endif
;;;470                        *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
;;;471                         return ((OS_FLAGS)0);
;;;472                     } else {                                       /* Specified blocking so check is scheduler is locked   */
;;;473                         if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
;;;474                             CPU_CRITICAL_EXIT();
;;;475    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;476                             TRACE_OS_FLAG_PEND_FAILED(p_grp);      /* Record the event.                                    */
;;;477    #endif
;;;478                            *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
;;;479                             return (0u);
;;;480                         }
;;;481                     }
;;;482                                                                    /* Lock the scheduler/re-enable interrupts              */
;;;483                     OS_CRITICAL_ENTER_CPU_EXIT();              
;;;484                     OS_FlagBlock(&pend_data,
;;;485                                  p_grp,
;;;486                                  flags,
;;;487                                  opt,
;;;488                                  timeout);
;;;489                     OS_CRITICAL_EXIT_NO_SCHED();
;;;490                 }
;;;491                 break;
;;;492    
;;;493            case OS_OPT_PEND_FLAG_SET_ANY:
;;;494                 flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
;;;495                 if (flags_rdy != 0u) {                             /* See if any flag set                                  */
;;;496                     if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
;;;497                         p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we got                     */
;;;498                     }
;;;499                     OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
;;;500    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;501                     if (p_ts != DEF_NULL) {
;;;502                        *p_ts  = p_grp->TS;
;;;503                     }
;;;504    #endif
;;;505                     CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
;;;506    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;507                     TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
;;;508    #endif
;;;509                    *p_err = OS_ERR_NONE;
;;;510                     return (flags_rdy);
;;;511                 } else {                                           /* Block task until events occur or timeout             */
;;;512                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
;;;513                         CPU_CRITICAL_EXIT();
;;;514                        *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
;;;515                         return ((OS_FLAGS)0);
;;;516                     } else {                                       /* Specified blocking so check is scheduler is locked   */
;;;517                         if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
;;;518                             CPU_CRITICAL_EXIT();
;;;519                            *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
;;;520                             return ((OS_FLAGS)0);
;;;521                         }
;;;522                     }
;;;523                                                                    /* Lock the scheduler/re-enable interrupts              */
;;;524                     OS_CRITICAL_ENTER_CPU_EXIT();              
;;;525                     OS_FlagBlock(&pend_data,
;;;526                                  p_grp,
;;;527                                  flags,
;;;528                                  opt,
;;;529                                  timeout);
;;;530                     OS_CRITICAL_EXIT_NO_SCHED();
;;;531                 }
;;;532                 break;
;;;533    
;;;534    #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
;;;535            case OS_OPT_PEND_FLAG_CLR_ALL:                          /* See if all required flags are cleared                */
;;;536                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags);     /* Extract only the bits we want                        */
;;;537                 if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
;;;538                     if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
;;;539                         p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we wanted                    */
;;;540                     }
;;;541                     OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
;;;542    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;543                     if (p_ts != DEF_NULL) {
;;;544                        *p_ts  = p_grp->TS;
;;;545                     }
;;;546    #endif
;;;547                     CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
;;;548    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;549                     TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
;;;550    #endif                 
;;;551                    *p_err = OS_ERR_NONE;
;;;552                     return (flags_rdy);
;;;553                 } else {                                           /* Block task until events occur or timeout             */
;;;554                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
;;;555                         CPU_CRITICAL_EXIT();
;;;556                        *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
;;;557                         return ((OS_FLAGS)0);
;;;558                     } else {                                       /* Specified blocking so check is scheduler is locked   */
;;;559                         if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
;;;560                             CPU_CRITICAL_EXIT();
;;;561                            *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
;;;562                             return (0);
;;;563                         }
;;;564                     }
;;;565                                                                
;;;566                     OS_CRITICAL_ENTER_CPU_EXIT();                  /* Lock the scheduler/re-enable interrupts              */
;;;567                     OS_FlagBlock(&pend_data,
;;;568                                  p_grp,
;;;569                                  flags,
;;;570                                  opt,
;;;571                                  timeout);
;;;572                     OS_CRITICAL_EXIT_NO_SCHED();
;;;573                 }
;;;574                 break;
;;;575    
;;;576            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;577                 flags_rdy = (~p_grp->Flags & flags);               /* Extract only the bits we want                        */
;;;578                 if (flags_rdy != 0u) {                             /* See if any flag cleared                              */
;;;579                     if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
;;;580                         p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we got                       */
;;;581                     }
;;;582                     OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
;;;583    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;584                     if (p_ts != DEF_NULL) {
;;;585                        *p_ts  = p_grp->TS;
;;;586                     }
;;;587    #endif
;;;588                     CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
;;;589    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;590                     TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
;;;591    #endif
;;;592                    *p_err = OS_ERR_NONE;
;;;593                     return (flags_rdy);
;;;594                 } else {                                           /* Block task until events occur or timeout             */
;;;595                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
;;;596                         CPU_CRITICAL_EXIT();
;;;597                        *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
;;;598                         return ((OS_FLAGS)0);
;;;599                     } else {                                       /* Specified blocking so check is scheduler is locked   */
;;;600                         if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
;;;601                             CPU_CRITICAL_EXIT();
;;;602                            *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
;;;603                             return (0u);
;;;604                         }
;;;605                     }
;;;606                                                                
;;;607                     OS_CRITICAL_ENTER_CPU_EXIT();                  /* Lock the scheduler/re-enable interrupts              */
;;;608                     OS_FlagBlock(&pend_data,              
;;;609                                  p_grp,
;;;610                                  flags,
;;;611                                  opt,
;;;612                                  timeout);
;;;613                     OS_CRITICAL_EXIT_NO_SCHED();
;;;614                 }
;;;615                 break;
;;;616    #endif
;;;617    
;;;618            default:
;;;619                 CPU_CRITICAL_EXIT();
;;;620    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;621                 TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
;;;622    #endif
;;;623                *p_err = OS_ERR_OPT_INVALID;
;;;624                 return (0u);
;;;625        }
;;;626    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;627        TRACE_OS_FLAG_PEND_BLOCK(p_grp);                            /* Record the event.                                    */
;;;628    #endif
;;;629        OSSched();                                                  /* Find next HPT ready to run                           */
;;;630    
;;;631        CPU_CRITICAL_ENTER();
;;;632        switch (OSTCBCurPtr->PendStatus) {
;;;633            case OS_STATUS_PEND_OK:                                 /* We got the event flags                               */
;;;634    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;635                 if (p_ts != DEF_NULL) {
;;;636                    *p_ts = OSTCBCurPtr->TS;
;;;637                 }
;;;638    #endif
;;;639    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;640                 TRACE_OS_FLAG_PEND(p_grp);                         /* Record the event.                                    */
;;;641    #endif
;;;642                *p_err = OS_ERR_NONE;
;;;643                 break;
;;;644    
;;;645            case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
;;;646    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;647                 if (p_ts != DEF_NULL) {
;;;648                    *p_ts = OSTCBCurPtr->TS;
;;;649                 }
;;;650    #endif
;;;651                 CPU_CRITICAL_EXIT();
;;;652    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;653                 TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
;;;654    #endif
;;;655                *p_err = OS_ERR_PEND_ABORT;
;;;656                 break;
;;;657    
;;;658            case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get semaphore within timeout */
;;;659                 if (p_ts != DEF_NULL) {
;;;660                    *p_ts = 0u;
;;;661                 }
;;;662                 CPU_CRITICAL_EXIT();
;;;663    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;664                 TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
;;;665    #endif
;;;666                *p_err = OS_ERR_TIMEOUT;
;;;667                 break;
;;;668    
;;;669            case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
;;;670    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;671                 if (p_ts != DEF_NULL) {
;;;672                    *p_ts = OSTCBCurPtr->TS;
;;;673                 }
;;;674    #endif
;;;675                 CPU_CRITICAL_EXIT();
;;;676    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;677                 TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
;;;678    #endif
;;;679                *p_err = OS_ERR_OBJ_DEL;
;;;680                 break;
;;;681    
;;;682            default:
;;;683                 CPU_CRITICAL_EXIT();
;;;684    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;685                 TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
;;;686    #endif
;;;687                *p_err = OS_ERR_STATUS_INVALID;
;;;688                 break;
;;;689        }
;;;690        if (*p_err != OS_ERR_NONE) {
;;;691            return (0u);
;;;692        }
;;;693    
;;;694        flags_rdy = OSTCBCurPtr->FlagsRdy;
;;;695        if (consume == DEF_TRUE) {                                  /* See if we need to consume the flags                  */
;;;696            switch (mode) {
;;;697                case OS_OPT_PEND_FLAG_SET_ALL:
;;;698                case OS_OPT_PEND_FLAG_SET_ANY:                      /* Clear ONLY the flags we got                          */
;;;699                     p_grp->Flags &= ~flags_rdy;
;;;700                     break;
;;;701    
;;;702    #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
;;;703                case OS_OPT_PEND_FLAG_CLR_ALL:
;;;704                case OS_OPT_PEND_FLAG_CLR_ANY:                      /* Set   ONLY the flags we got                          */
;;;705                     p_grp->Flags |=  flags_rdy;
;;;706                     break;
;;;707    #endif
;;;708                default:
;;;709                     CPU_CRITICAL_EXIT();
;;;710                    *p_err = OS_ERR_OPT_INVALID;
;;;711                     return (0u);
;;;712            }
;;;713        }
;;;714        CPU_CRITICAL_EXIT();
;;;715       *p_err = OS_ERR_NONE;                                        /* Event(s) must have occurred                          */
;;;716        return (flags_rdy);
;;;717    }
000022  b00f              ADD      sp,sp,#0x3c
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.40|
000028  b925              CBNZ     r5,|L2.52|
00002a  f64550c3          MOV      r0,#0x5dc3            ;392
00002e  8020              STRH     r0,[r4,#0]            ;392
000030  2000              MOVS     r0,#0                 ;393
000032  e7f6              B        |L2.34|
                  |L2.52|
000034  f2480101          MOV      r1,#0x8001            ;395
000038  eba80001          SUB      r0,r8,r1              ;395
00003c  4588              CMP      r8,r1                 ;395
00003e  d036              BEQ      |L2.174|
000040  dc1a              BGT      |L2.120|
000042  f2401101          MOV      r1,#0x101             ;395
000046  eba80001          SUB      r0,r8,r1              ;395
00004a  4588              CMP      r8,r1                 ;395
00004c  d02b              BEQ      |L2.166|
00004e  dc0c              BGT      |L2.106|
000050  f1b80f01          CMP      r8,#1                 ;395
000054  d023              BEQ      |L2.158|
000056  f1b80f02          CMP      r8,#2                 ;395
00005a  d021              BEQ      |L2.160|
00005c  f1b80f04          CMP      r8,#4                 ;395
000060  d01f              BEQ      |L2.162|
000062  f1b80f08          CMP      r8,#8                 ;395
000066  d12a              BNE      |L2.190|
000068  e01c              B        |L2.164|
                  |L2.106|
00006a  2801              CMP      r0,#1                 ;395
00006c  d01c              BEQ      |L2.168|
00006e  2803              CMP      r0,#3                 ;395
000070  d01b              BEQ      |L2.170|
000072  2807              CMP      r0,#7                 ;395
000074  d123              BNE      |L2.190|
000076  e019              B        |L2.172|
                  |L2.120|
000078  f5b07f80          CMP      r0,#0x100             ;395
00007c  d01b              BEQ      |L2.182|
00007e  dc06              BGT      |L2.142|
000080  2801              CMP      r0,#1                 ;395
000082  d015              BEQ      |L2.176|
000084  2803              CMP      r0,#3                 ;395
000086  d014              BEQ      |L2.178|
000088  2807              CMP      r0,#7                 ;395
00008a  d118              BNE      |L2.190|
00008c  e012              B        |L2.180|
                  |L2.142|
00008e  f2a01001          SUB      r0,r0,#0x101          ;395
000092  b188              CBZ      r0,|L2.184|
000094  2802              CMP      r0,#2                 ;395
000096  d010              BEQ      |L2.186|
000098  2806              CMP      r0,#6                 ;395
00009a  d110              BNE      |L2.190|
00009c  e00e              B        |L2.188|
                  |L2.158|
00009e  bf00              NOP                            ;397
                  |L2.160|
0000a0  bf00              NOP                            ;398
                  |L2.162|
0000a2  bf00              NOP                            ;399
                  |L2.164|
0000a4  bf00              NOP                            ;400
                  |L2.166|
0000a6  bf00              NOP                            ;401
                  |L2.168|
0000a8  bf00              NOP                            ;402
                  |L2.170|
0000aa  bf00              NOP                            ;403
                  |L2.172|
0000ac  bf00              NOP                            ;404
                  |L2.174|
0000ae  bf00              NOP                            ;405
                  |L2.176|
0000b0  bf00              NOP                            ;406
                  |L2.178|
0000b2  bf00              NOP                            ;407
                  |L2.180|
0000b4  bf00              NOP                            ;408
                  |L2.182|
0000b6  bf00              NOP                            ;409
                  |L2.184|
0000b8  bf00              NOP                            ;410
                  |L2.186|
0000ba  bf00              NOP                            ;411
                  |L2.188|
0000bc  e004              B        |L2.200|
                  |L2.190|
0000be  f6456025          MOV      r0,#0x5e25            ;418
0000c2  8020              STRH     r0,[r4,#0]            ;418
0000c4  2000              MOVS     r0,#0                 ;419
0000c6  e7ac              B        |L2.34|
                  |L2.200|
0000c8  bf00              NOP                            ;412
0000ca  49b8              LDR      r1,|L2.940|
0000cc  6828              LDR      r0,[r5,#0]            ;424
0000ce  4288              CMP      r0,r1                 ;424
0000d0  d004              BEQ      |L2.220|
0000d2  f64550c4          MOV      r0,#0x5dc4            ;428
0000d6  8020              STRH     r0,[r4,#0]            ;428
0000d8  2000              MOVS     r0,#0                 ;429
0000da  e7a2              B        |L2.34|
                  |L2.220|
0000dc  f4087080          AND      r0,r8,#0x100          ;433
0000e0  b110              CBZ      r0,|L2.232|
0000e2  f04f0a01          MOV      r10,#1                ;434
0000e6  e001              B        |L2.236|
                  |L2.232|
0000e8  f04f0a00          MOV      r10,#0                ;436
                  |L2.236|
0000ec  b10e              CBZ      r6,|L2.242|
0000ee  2000              MOVS     r0,#0                 ;440
0000f0  6030              STR      r0,[r6,#0]            ;440
                  |L2.242|
0000f2  f0080b0f          AND      r11,r8,#0xf           ;443
0000f6  bf00              NOP                            ;444
0000f8  bf00              NOP                            ;444
0000fa  f7fffffe          BL       CPU_SR_Save
0000fe  9002              STR      r0,[sp,#8]            ;444
000100  bf00              NOP                            ;444
000102  f7fffffe          BL       CPU_IntDisMeasStart
000106  bf00              NOP                            ;444
000108  f1bb0f04          CMP      r11,#4                ;445
00010c  d003              BEQ      |L2.278|
00010e  f1bb0f08          CMP      r11,#8                ;445
000112  d171              BNE      |L2.504|
000114  e052              B        |L2.444|
                  |L2.278|
000116  6a28              LDR      r0,[r5,#0x20]         ;447
000118  ea000709          AND      r7,r0,r9              ;447
00011c  454f              CMP      r7,r9                 ;448
00011e  d119              BNE      |L2.340|
000120  f1ba0f01          CMP      r10,#1                ;449
000124  d102              BNE      |L2.300|
000126  6a28              LDR      r0,[r5,#0x20]         ;450
000128  43b8              BICS     r0,r0,r7              ;450
00012a  6228              STR      r0,[r5,#0x20]         ;450
                  |L2.300|
00012c  48a0              LDR      r0,|L2.944|
00012e  6800              LDR      r0,[r0,#0]            ;452  ; OSTCBCurPtr
000130  f8c07080          STR      r7,[r0,#0x80]         ;452
000134  b10e              CBZ      r6,|L2.314|
000136  6a68              LDR      r0,[r5,#0x24]         ;455
000138  6030              STR      r0,[r6,#0]            ;455
                  |L2.314|
00013a  bf00              NOP                            ;458
00013c  f7fffffe          BL       CPU_IntDisMeasStop
000140  bf00              NOP                            ;458
000142  9802              LDR      r0,[sp,#8]            ;458
000144  f7fffffe          BL       CPU_SR_Restore
000148  bf00              NOP                            ;458
00014a  bf00              NOP                            ;458
00014c  2000              MOVS     r0,#0                 ;462
00014e  8020              STRH     r0,[r4,#0]            ;462
000150  4638              MOV      r0,r7                 ;463
000152  e766              B        |L2.34|
                  |L2.340|
000154  f4084000          AND      r0,r8,#0x8000         ;465
000158  b168              CBZ      r0,|L2.374|
00015a  bf00              NOP                            ;466
00015c  f7fffffe          BL       CPU_IntDisMeasStop
000160  bf00              NOP                            ;466
000162  9802              LDR      r0,[sp,#8]            ;466
000164  f7fffffe          BL       CPU_SR_Restore
000168  bf00              NOP                            ;466
00016a  bf00              NOP                            ;466
00016c  f24610b0          MOV      r0,#0x61b0            ;470
000170  8020              STRH     r0,[r4,#0]            ;470
000172  2000              MOVS     r0,#0                 ;471
000174  e755              B        |L2.34|
                  |L2.374|
000176  488f              LDR      r0,|L2.948|
000178  7800              LDRB     r0,[r0,#0]            ;473  ; OSSchedLockNestingCtr
00017a  b168              CBZ      r0,|L2.408|
00017c  bf00              NOP                            ;474
00017e  f7fffffe          BL       CPU_IntDisMeasStop
000182  bf00              NOP                            ;474
000184  9802              LDR      r0,[sp,#8]            ;474
000186  f7fffffe          BL       CPU_SR_Restore
00018a  bf00              NOP                            ;474
00018c  bf00              NOP                            ;474
00018e  f6465063          MOV      r0,#0x6d63            ;478
000192  8020              STRH     r0,[r4,#0]            ;478
000194  2000              MOVS     r0,#0                 ;479
000196  e744              B        |L2.34|
                  |L2.408|
000198  980d              LDR      r0,[sp,#0x34]         ;484
00019a  4643              MOV      r3,r8                 ;484
00019c  464a              MOV      r2,r9                 ;484
00019e  4629              MOV      r1,r5                 ;484
0001a0  9000              STR      r0,[sp,#0]            ;484
0001a2  a803              ADD      r0,sp,#0xc            ;484
0001a4  f7fffffe          BL       OS_FlagBlock
0001a8  bf00              NOP                            ;489
0001aa  f7fffffe          BL       CPU_IntDisMeasStop
0001ae  bf00              NOP                            ;489
0001b0  9802              LDR      r0,[sp,#8]            ;489
0001b2  f7fffffe          BL       CPU_SR_Restore
0001b6  bf00              NOP                            ;489
0001b8  bf00              NOP                            ;489
0001ba  e060              B        |L2.638|
                  |L2.444|
0001bc  6a28              LDR      r0,[r5,#0x20]         ;494
0001be  ea000709          AND      r7,r0,r9              ;494
0001c2  b1d7              CBZ      r7,|L2.506|
0001c4  f1ba0f01          CMP      r10,#1                ;496
0001c8  d102              BNE      |L2.464|
0001ca  6a28              LDR      r0,[r5,#0x20]         ;497
0001cc  43b8              BICS     r0,r0,r7              ;497
0001ce  6228              STR      r0,[r5,#0x20]         ;497
                  |L2.464|
0001d0  4877              LDR      r0,|L2.944|
0001d2  6800              LDR      r0,[r0,#0]            ;499  ; OSTCBCurPtr
0001d4  f8c07080          STR      r7,[r0,#0x80]         ;499
0001d8  b10e              CBZ      r6,|L2.478|
0001da  6a68              LDR      r0,[r5,#0x24]         ;502
0001dc  6030              STR      r0,[r6,#0]            ;502
                  |L2.478|
0001de  bf00              NOP                            ;505
0001e0  f7fffffe          BL       CPU_IntDisMeasStop
0001e4  bf00              NOP                            ;505
0001e6  9802              LDR      r0,[sp,#8]            ;505
0001e8  f7fffffe          BL       CPU_SR_Restore
0001ec  bf00              NOP                            ;505
0001ee  bf00              NOP                            ;505
0001f0  2000              MOVS     r0,#0                 ;509
0001f2  8020              STRH     r0,[r4,#0]            ;509
0001f4  4638              MOV      r0,r7                 ;510
0001f6  e714              B        |L2.34|
                  |L2.504|
0001f8  e033              B        |L2.610|
                  |L2.506|
0001fa  f4084000          AND      r0,r8,#0x8000         ;512
0001fe  b168              CBZ      r0,|L2.540|
000200  bf00              NOP                            ;513
000202  f7fffffe          BL       CPU_IntDisMeasStop
000206  bf00              NOP                            ;513
000208  9802              LDR      r0,[sp,#8]            ;513
00020a  f7fffffe          BL       CPU_SR_Restore
00020e  bf00              NOP                            ;513
000210  bf00              NOP                            ;513
000212  f24610b0          MOV      r0,#0x61b0            ;514
000216  8020              STRH     r0,[r4,#0]            ;514
000218  2000              MOVS     r0,#0                 ;515
00021a  e702              B        |L2.34|
                  |L2.540|
00021c  4865              LDR      r0,|L2.948|
00021e  7800              LDRB     r0,[r0,#0]            ;517  ; OSSchedLockNestingCtr
000220  b168              CBZ      r0,|L2.574|
000222  bf00              NOP                            ;518
000224  f7fffffe          BL       CPU_IntDisMeasStop
000228  bf00              NOP                            ;518
00022a  9802              LDR      r0,[sp,#8]            ;518
00022c  f7fffffe          BL       CPU_SR_Restore
000230  bf00              NOP                            ;518
000232  bf00              NOP                            ;518
000234  f6465063          MOV      r0,#0x6d63            ;519
000238  8020              STRH     r0,[r4,#0]            ;519
00023a  2000              MOVS     r0,#0                 ;520
00023c  e6f1              B        |L2.34|
                  |L2.574|
00023e  980d              LDR      r0,[sp,#0x34]         ;525
000240  4643              MOV      r3,r8                 ;525
000242  464a              MOV      r2,r9                 ;525
000244  4629              MOV      r1,r5                 ;525
000246  9000              STR      r0,[sp,#0]            ;525
000248  a803              ADD      r0,sp,#0xc            ;525
00024a  f7fffffe          BL       OS_FlagBlock
00024e  bf00              NOP                            ;530
000250  f7fffffe          BL       CPU_IntDisMeasStop
000254  bf00              NOP                            ;530
000256  9802              LDR      r0,[sp,#8]            ;530
000258  f7fffffe          BL       CPU_SR_Restore
00025c  bf00              NOP                            ;530
00025e  bf00              NOP                            ;530
000260  e00d              B        |L2.638|
                  |L2.610|
000262  bf00              NOP                            ;619
000264  f7fffffe          BL       CPU_IntDisMeasStop
000268  bf00              NOP                            ;619
00026a  9802              LDR      r0,[sp,#8]            ;619
00026c  f7fffffe          BL       CPU_SR_Restore
000270  bf00              NOP                            ;619
000272  bf00              NOP                            ;619
000274  f6456025          MOV      r0,#0x5e25            ;623
000278  8020              STRH     r0,[r4,#0]            ;623
00027a  2000              MOVS     r0,#0                 ;624
00027c  e6d1              B        |L2.34|
                  |L2.638|
00027e  bf00              NOP                            ;491
000280  f7fffffe          BL       OSSched
000284  bf00              NOP                            ;631
000286  bf00              NOP                            ;631
000288  f7fffffe          BL       CPU_SR_Save
00028c  9002              STR      r0,[sp,#8]            ;631
00028e  bf00              NOP                            ;631
000290  f7fffffe          BL       CPU_IntDisMeasStart
000294  bf00              NOP                            ;631
000296  4846              LDR      r0,|L2.944|
000298  6800              LDR      r0,[r0,#0]            ;632  ; OSTCBCurPtr
00029a  f8900035          LDRB     r0,[r0,#0x35]         ;632
00029e  b130              CBZ      r0,|L2.686|
0002a0  2801              CMP      r0,#1                 ;632
0002a2  d00c              BEQ      |L2.702|
0002a4  2802              CMP      r0,#2                 ;632
0002a6  d02c              BEQ      |L2.770|
0002a8  2803              CMP      r0,#3                 ;632
0002aa  d13c              BNE      |L2.806|
0002ac  e019              B        |L2.738|
                  |L2.686|
0002ae  b11e              CBZ      r6,|L2.696|
0002b0  483f              LDR      r0,|L2.944|
0002b2  6800              LDR      r0,[r0,#0]            ;636  ; OSTCBCurPtr
0002b4  6c80              LDR      r0,[r0,#0x48]         ;636
0002b6  6030              STR      r0,[r6,#0]            ;636
                  |L2.696|
0002b8  2000              MOVS     r0,#0                 ;642
0002ba  8020              STRH     r0,[r4,#0]            ;642
0002bc  e040              B        |L2.832|
                  |L2.702|
0002be  b11e              CBZ      r6,|L2.712|
0002c0  483b              LDR      r0,|L2.944|
0002c2  6800              LDR      r0,[r0,#0]            ;648  ; OSTCBCurPtr
0002c4  6c80              LDR      r0,[r0,#0x48]         ;648
0002c6  6030              STR      r0,[r6,#0]            ;648
                  |L2.712|
0002c8  bf00              NOP                            ;651
0002ca  f7fffffe          BL       CPU_IntDisMeasStop
0002ce  bf00              NOP                            ;651
0002d0  9802              LDR      r0,[sp,#8]            ;651
0002d2  f7fffffe          BL       CPU_SR_Restore
0002d6  bf00              NOP                            ;651
0002d8  bf00              NOP                            ;651
0002da  f24610a9          MOV      r0,#0x61a9            ;655
0002de  8020              STRH     r0,[r4,#0]            ;655
0002e0  e02e              B        |L2.832|
                  |L2.738|
0002e2  b10e              CBZ      r6,|L2.744|
0002e4  2000              MOVS     r0,#0                 ;660
0002e6  6030              STR      r0,[r6,#0]            ;660
                  |L2.744|
0002e8  bf00              NOP                            ;662
0002ea  f7fffffe          BL       CPU_IntDisMeasStop
0002ee  bf00              NOP                            ;662
0002f0  9802              LDR      r0,[sp,#8]            ;662
0002f2  f7fffffe          BL       CPU_SR_Restore
0002f6  bf00              NOP                            ;662
0002f8  bf00              NOP                            ;662
0002fa  f24720d9          MOV      r0,#0x72d9            ;666
0002fe  8020              STRH     r0,[r4,#0]            ;666
000300  e01e              B        |L2.832|
                  |L2.770|
000302  b11e              CBZ      r6,|L2.780|
000304  482a              LDR      r0,|L2.944|
000306  6800              LDR      r0,[r0,#0]            ;672  ; OSTCBCurPtr
000308  6c80              LDR      r0,[r0,#0x48]         ;672
00030a  6030              STR      r0,[r6,#0]            ;672
                  |L2.780|
00030c  bf00              NOP                            ;675
00030e  f7fffffe          BL       CPU_IntDisMeasStop
000312  bf00              NOP                            ;675
000314  9802              LDR      r0,[sp,#8]            ;675
000316  f7fffffe          BL       CPU_SR_Restore
00031a  bf00              NOP                            ;675
00031c  bf00              NOP                            ;675
00031e  f64550c2          MOV      r0,#0x5dc2            ;679
000322  8020              STRH     r0,[r4,#0]            ;679
000324  e00c              B        |L2.832|
                  |L2.806|
000326  bf00              NOP                            ;683
000328  f7fffffe          BL       CPU_IntDisMeasStop
00032c  bf00              NOP                            ;683
00032e  9802              LDR      r0,[sp,#8]            ;683
000330  f7fffffe          BL       CPU_SR_Restore
000334  bf00              NOP                            ;683
000336  bf00              NOP                            ;683
000338  f646602e          MOV      r0,#0x6e2e            ;687
00033c  8020              STRH     r0,[r4,#0]            ;687
00033e  bf00              NOP                            ;688
                  |L2.832|
000340  bf00              NOP                            ;643
000342  8820              LDRH     r0,[r4,#0]            ;690
000344  b108              CBZ      r0,|L2.842|
000346  2000              MOVS     r0,#0                 ;691
000348  e66b              B        |L2.34|
                  |L2.842|
00034a  4819              LDR      r0,|L2.944|
00034c  6800              LDR      r0,[r0,#0]            ;694  ; OSTCBCurPtr
00034e  f8d07080          LDR      r7,[r0,#0x80]         ;694
000352  f1ba0f01          CMP      r10,#1                ;695
000356  d11a              BNE      |L2.910|
000358  f1bb0f04          CMP      r11,#4                ;696
00035c  d003              BEQ      |L2.870|
00035e  f1bb0f08          CMP      r11,#8                ;696
000362  d105              BNE      |L2.880|
000364  e000              B        |L2.872|
                  |L2.870|
000366  bf00              NOP                            ;698
                  |L2.872|
000368  6a28              LDR      r0,[r5,#0x20]         ;699
00036a  43b8              BICS     r0,r0,r7              ;699
00036c  6228              STR      r0,[r5,#0x20]         ;699
00036e  e00d              B        |L2.908|
                  |L2.880|
000370  bf00              NOP                            ;709
000372  f7fffffe          BL       CPU_IntDisMeasStop
000376  bf00              NOP                            ;709
000378  9802              LDR      r0,[sp,#8]            ;709
00037a  f7fffffe          BL       CPU_SR_Restore
00037e  bf00              NOP                            ;709
000380  bf00              NOP                            ;709
000382  f6456025          MOV      r0,#0x5e25            ;710
000386  8020              STRH     r0,[r4,#0]            ;710
000388  2000              MOVS     r0,#0                 ;711
00038a  e64a              B        |L2.34|
                  |L2.908|
00038c  bf00              NOP                            ;700
                  |L2.910|
00038e  bf00              NOP                            ;714
000390  f7fffffe          BL       CPU_IntDisMeasStop
000394  bf00              NOP                            ;714
000396  9802              LDR      r0,[sp,#8]            ;714
000398  f7fffffe          BL       CPU_SR_Restore
00039c  bf00              NOP                            ;714
00039e  bf00              NOP                            ;714
0003a0  2000              MOVS     r0,#0                 ;715
0003a2  8020              STRH     r0,[r4,#0]            ;715
0003a4  4638              MOV      r0,r7                 ;716
0003a6  e63c              B        |L2.34|
;;;718    
                          ENDP

                  |L2.936|
                          DCD      OSIntNestingCtr
                  |L2.940|
                          DCD      0x47414c46
                  |L2.944|
                          DCD      OSTCBCurPtr
                  |L2.948|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;871    
;;;872    OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;873    {
000002  4604              MOV      r4,r0
;;;874        OS_FLAGS   flags;
;;;875        CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;876    
;;;877    
;;;878    
;;;879    #ifdef OS_SAFETY_CRITICAL
;;;880        if (p_err == DEF_NULL) {
;;;881            OS_SAFETY_CRITICAL_EXCEPTION();
;;;882            return ((OS_FLAGS)0);
;;;883        }
;;;884    #endif
;;;885    
;;;886    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;887        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;888           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;889            return (0u);
;;;890        }
;;;891    #endif
;;;892    
;;;893    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;894        if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
000006  4811              LDR      r0,|L3.76|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b120              CBZ      r0,|L3.22|
;;;895           *p_err = OS_ERR_PEND_ISR;                                /* ... can't get from an ISR                            */
00000c  f24610ae          MOV      r0,#0x61ae
000010  8020              STRH     r0,[r4,#0]
;;;896            return (0u);
000012  2000              MOVS     r0,#0
                  |L3.20|
;;;897        }
;;;898    #endif
;;;899    
;;;900        CPU_CRITICAL_ENTER();
;;;901        flags = OSTCBCurPtr->FlagsRdy;
;;;902        CPU_CRITICAL_EXIT();
;;;903       *p_err = OS_ERR_NONE;
;;;904        return (flags);
;;;905    }
000014  bd70              POP      {r4-r6,pc}
                  |L3.22|
000016  bf00              NOP                            ;900
000018  bf00              NOP                            ;900
00001a  f7fffffe          BL       CPU_SR_Save
00001e  4606              MOV      r6,r0                 ;900
000020  bf00              NOP                            ;900
000022  f7fffffe          BL       CPU_IntDisMeasStart
000026  bf00              NOP                            ;900
000028  4809              LDR      r0,|L3.80|
00002a  6800              LDR      r0,[r0,#0]            ;901  ; OSTCBCurPtr
00002c  f8d05080          LDR      r5,[r0,#0x80]         ;901
000030  bf00              NOP                            ;902
000032  f7fffffe          BL       CPU_IntDisMeasStop
000036  bf00              NOP                            ;902
000038  4630              MOV      r0,r6                 ;902
00003a  f7fffffe          BL       CPU_SR_Restore
00003e  bf00              NOP                            ;902
000040  bf00              NOP                            ;902
000042  2000              MOVS     r0,#0                 ;903
000044  8020              STRH     r0,[r4,#0]            ;903
000046  4628              MOV      r0,r5                 ;904
000048  e7e4              B        |L3.20|
;;;906    
                          ENDP

00004a  0000              DCW      0x0000
                  |L3.76|
                          DCD      OSIntNestingCtr
                  |L3.80|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=2

                  OSFlagPost PROC
;;;950    
;;;951    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;952                          OS_FLAGS      flags,
;;;953                          OS_OPT        opt,
;;;954                          OS_ERR       *p_err)
;;;955    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;956        OS_FLAGS  flags_cur;
;;;957        CPU_TS    ts;
;;;958    
;;;959    
;;;960    
;;;961    #ifdef OS_SAFETY_CRITICAL
;;;962        if (p_err == DEF_NULL) {
;;;963            OS_SAFETY_CRITICAL_EXCEPTION();
;;;964            return (0u);
;;;965        }
;;;966    #endif
;;;967    
;;;968    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;969        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;970           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;971            return (0u);
;;;972        }
;;;973    #endif
;;;974    
;;;975    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;976        if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
00000c  b92d              CBNZ     r5,|L4.26|
;;;977    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;978            TRACE_OS_FLAG_POST_FAILED(p_grp);                       /* Record the event.                                    */
;;;979    #endif
;;;980           *p_err  = OS_ERR_OBJ_PTR_NULL;
00000e  f64550c3          MOV      r0,#0x5dc3
000012  8020              STRH     r0,[r4,#0]
;;;981            return (0u);
000014  2000              MOVS     r0,#0
                  |L4.22|
;;;982        }
;;;983        switch (opt) {                                              /* Validate 'opt'                                       */
;;;984            case OS_OPT_POST_FLAG_SET:
;;;985            case OS_OPT_POST_FLAG_CLR:
;;;986            case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
;;;987            case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
;;;988                 break;
;;;989    
;;;990            default:
;;;991    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;992                 TRACE_OS_FLAG_POST_FAILED(p_grp);                  /* Record the event.                                    */
;;;993    #endif
;;;994                *p_err = OS_ERR_OPT_INVALID;
;;;995                 return (0u);
;;;996        }
;;;997    #endif
;;;998    
;;;999    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;1000       if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Make sure we are pointing to an event flag grp       */
;;;1001   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1002           TRACE_OS_FLAG_POST_FAILED(p_grp);                       /* Record the event.                                    */
;;;1003   #endif
;;;1004          *p_err = OS_ERR_OBJ_TYPE;
;;;1005           return (0u);
;;;1006       }
;;;1007   #endif
;;;1008   
;;;1009   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1010       ts = OS_TS_GET();                                           /* Get timestamp                                        */
;;;1011   #else
;;;1012       ts = 0u;
;;;1013   #endif
;;;1014   #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;1015       if (OSIntNestingCtr > 0u) {                                 /* See if called from an ISR                            */
;;;1016           OS_IntQPost(OS_OBJ_TYPE_FLAG,                           /* Post to ISR queue                                    */
;;;1017                       (void *)p_grp,
;;;1018                       DEF_NULL,
;;;1019                       0u,
;;;1020                       flags,
;;;1021                       opt,
;;;1022                       ts,
;;;1023                       p_err);
;;;1024   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1025           TRACE_OS_FLAG_POST(p_grp);                              /* Record the event.                                    */
;;;1026   #endif
;;;1027           return (0u);
;;;1028       }
;;;1029   #endif
;;;1030   
;;;1031       flags_cur = OS_FlagPost(p_grp,
;;;1032                               flags,
;;;1033                               opt,
;;;1034                               ts,
;;;1035                               p_err);
;;;1036   
;;;1037   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1038       TRACE_OS_FLAG_POST(p_grp);                                  /* Record the event.                                    */
;;;1039   #endif    
;;;1040   
;;;1041       return (flags_cur);
;;;1042   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L4.26|
00001a  b14e              CBZ      r6,|L4.48|
00001c  2e01              CMP      r6,#1                 ;983
00001e  d008              BEQ      |L4.50|
000020  f5b64f00          CMP      r6,#0x8000            ;983
000024  d006              BEQ      |L4.52|
000026  f46f4000          MVN      r0,#0x8000            ;983
00002a  4430              ADD      r0,r0,r6              ;983
00002c  b920              CBNZ     r0,|L4.56|
00002e  e002              B        |L4.54|
                  |L4.48|
000030  bf00              NOP                            ;985
                  |L4.50|
000032  bf00              NOP                            ;986
                  |L4.52|
000034  bf00              NOP                            ;987
                  |L4.54|
000036  e004              B        |L4.66|
                  |L4.56|
000038  f6456025          MOV      r0,#0x5e25            ;994
00003c  8020              STRH     r0,[r4,#0]            ;994
00003e  2000              MOVS     r0,#0                 ;995
000040  e7e9              B        |L4.22|
                  |L4.66|
000042  bf00              NOP                            ;988
000044  490a              LDR      r1,|L4.112|
000046  6828              LDR      r0,[r5,#0]            ;1000
000048  4288              CMP      r0,r1                 ;1000
00004a  d004              BEQ      |L4.86|
00004c  f64550c4          MOV      r0,#0x5dc4            ;1004
000050  8020              STRH     r0,[r4,#0]            ;1004
000052  2000              MOVS     r0,#0                 ;1005
000054  e7df              B        |L4.22|
                  |L4.86|
000056  f7fffffe          BL       CPU_TS_TmrRd
00005a  4681              MOV      r9,r0                 ;1010
00005c  464b              MOV      r3,r9                 ;1031
00005e  4632              MOV      r2,r6                 ;1031
000060  4641              MOV      r1,r8                 ;1031
000062  4628              MOV      r0,r5                 ;1031
000064  9400              STR      r4,[sp,#0]            ;1031
000066  f7fffffe          BL       OS_FlagPost
00006a  4607              MOV      r7,r0                 ;1031
00006c  4638              MOV      r0,r7                 ;1041
00006e  e7d2              B        |L4.22|
;;;1043   
                          ENDP

                  |L4.112|
                          DCD      0x47414c46

                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;1080   
;;;1081   void  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1082                       OS_FLAG_GRP   *p_grp,
;;;1083                       OS_FLAGS       flags,
;;;1084                       OS_OPT         opt,
;;;1085                       OS_TICK        timeout)
;;;1086   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1087       OSTCBCurPtr->FlagsPend = flags;                             /* Save the flags that we need to wait for              */
000010  4809              LDR      r0,|L5.56|
000012  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000014  67c4              STR      r4,[r0,#0x7c]
;;;1088       OSTCBCurPtr->FlagsOpt  = opt;                               /* Save the type of wait we are doing                   */
000016  4808              LDR      r0,|L5.56|
000018  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00001a  f8a05084          STRH     r5,[r0,#0x84]
;;;1089       OSTCBCurPtr->FlagsRdy  = 0u;
00001e  2000              MOVS     r0,#0
000020  4905              LDR      r1,|L5.56|
000022  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000024  f8c10080          STR      r0,[r1,#0x80]
;;;1090   
;;;1091       OS_Pend(p_pend_data,
000028  4643              MOV      r3,r8
00002a  2201              MOVS     r2,#1
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       OS_Pend
;;;1092               (OS_PEND_OBJ *)((void *)p_grp),
;;;1093                OS_TASK_PEND_ON_FLAG,
;;;1094                timeout);
;;;1095   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1096   
                          ENDP

                  |L5.56|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_FlagClr||, CODE, READONLY, ALIGN=2

                  OS_FlagClr PROC
;;;1113   
;;;1114   void  OS_FlagClr (OS_FLAG_GRP  *p_grp)
000000  b570              PUSH     {r4-r6,lr}
;;;1115   {
000002  4604              MOV      r4,r0
;;;1116       OS_PEND_LIST  *p_pend_list;
;;;1117   
;;;1118   
;;;1119   #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;1120       p_grp->Type             = OS_OBJ_TYPE_NONE;
000004  4805              LDR      r0,|L6.28|
000006  6020              STR      r0,[r4,#0]
;;;1121   #endif
;;;1122   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1123       p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                         */
000008  a005              ADR      r0,|L6.32|
00000a  6060              STR      r0,[r4,#4]
;;;1124   #endif
;;;1125       p_grp->Flags            =  0u;
00000c  2000              MOVS     r0,#0
00000e  6220              STR      r0,[r4,#0x20]
;;;1126       p_pend_list             = &p_grp->PendList;
000010  f1040508          ADD      r5,r4,#8
;;;1127       OS_PendListInit(p_pend_list);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       OS_PendListInit
;;;1128   }
00001a  bd70              POP      {r4-r6,pc}
;;;1129   
                          ENDP

                  |L6.28|
                          DCD      0x454e4f4e
                  |L6.32|
000020  3f464c41          DCB      "?FLAG",0
000024  4700    
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||i.OS_FlagDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListAdd PROC
;;;1146   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1147   void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
000000  a109              ADR      r1,|L7.40|
;;;1148   {
;;;1149       p_grp->DbgNamePtr                = (CPU_CHAR *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;1150       p_grp->DbgPrevPtr                = DEF_NULL;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;1151       if (OSFlagDbgListPtr == DEF_NULL) {
000008  4908              LDR      r1,|L7.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
00000c  b911              CBNZ     r1,|L7.20|
;;;1152           p_grp->DbgNextPtr            = DEF_NULL;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L7.32|
                  |L7.20|
;;;1153       } else {
;;;1154           p_grp->DbgNextPtr            = OSFlagDbgListPtr;
000014  4905              LDR      r1,|L7.44|
000016  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;1155           OSFlagDbgListPtr->DbgPrevPtr = p_grp;
00001a  4904              LDR      r1,|L7.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L7.32|
;;;1156       }
;;;1157       OSFlagDbgListPtr                 = p_grp;
000020  4902              LDR      r1,|L7.44|
000022  6008              STR      r0,[r1,#0]  ; OSFlagDbgListPtr
;;;1158   }
000024  4770              BX       lr
;;;1159   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L7.44|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListRemove PROC
;;;1161   
;;;1162   void  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
000000  6942              LDR      r2,[r0,#0x14]
;;;1163   {
;;;1164       OS_FLAG_GRP  *p_grp_next;
;;;1165       OS_FLAG_GRP  *p_grp_prev;
;;;1166   
;;;1167   
;;;1168       p_grp_prev = p_grp->DbgPrevPtr;
;;;1169       p_grp_next = p_grp->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;1170   
;;;1171       if (p_grp_prev == DEF_NULL) {
000004  b93a              CBNZ     r2,|L8.22|
;;;1172           OSFlagDbgListPtr = p_grp_next;
000006  4b09              LDR      r3,|L8.44|
000008  6019              STR      r1,[r3,#0]  ; OSFlagDbgListPtr
;;;1173           if (p_grp_next != DEF_NULL) {
00000a  b109              CBZ      r1,|L8.16|
;;;1174               p_grp_next->DbgPrevPtr = DEF_NULL;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L8.16|
;;;1175           }
;;;1176           p_grp->DbgNextPtr = DEF_NULL;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L8.42|
                  |L8.22|
;;;1177   
;;;1178       } else if (p_grp_next == DEF_NULL) {
000016  b919              CBNZ     r1,|L8.32|
;;;1179           p_grp_prev->DbgNextPtr = DEF_NULL;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;1180           p_grp->DbgPrevPtr      = DEF_NULL;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L8.42|
                  |L8.32|
;;;1181   
;;;1182       } else {
;;;1183           p_grp_prev->DbgNextPtr =  p_grp_next;
000020  6191              STR      r1,[r2,#0x18]
;;;1184           p_grp_next->DbgPrevPtr =  p_grp_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;1185           p_grp->DbgNextPtr      = DEF_NULL;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;1186           p_grp->DbgPrevPtr      = DEF_NULL;
000028  6143              STR      r3,[r0,#0x14]
                  |L8.42|
;;;1187       }
;;;1188   }
00002a  4770              BX       lr
;;;1189   #endif
                          ENDP

                  |L8.44|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagPost||, CODE, READONLY, ALIGN=1

                  OS_FlagPost PROC
;;;1234   
;;;1235   OS_FLAGS  OS_FlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1236                          OS_FLAGS      flags,
;;;1237                          OS_OPT        opt,
;;;1238                          CPU_TS        ts,
;;;1239                          OS_ERR       *p_err)
;;;1240   {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  9f0e              LDR      r7,[sp,#0x38]
;;;1241       OS_FLAGS        flags_cur;
;;;1242       OS_FLAGS        flags_rdy;
;;;1243       OS_OPT          mode;
;;;1244       OS_PEND_DATA   *p_pend_data;
;;;1245       OS_PEND_DATA   *p_pend_data_next;
;;;1246       OS_PEND_LIST   *p_pend_list;
;;;1247       OS_TCB         *p_tcb;
;;;1248       CPU_SR_ALLOC();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1249   
;;;1250   
;;;1251   #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;1252       (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
;;;1253   #endif
;;;1254   
;;;1255       CPU_CRITICAL_ENTER();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStart
000024  bf00              NOP      
;;;1256       switch (opt) {
000026  f1b90f00          CMP      r9,#0
00002a  d00a              BEQ      |L9.66|
00002c  f1b90f01          CMP      r9,#1
000030  d00d              BEQ      |L9.78|
000032  f5b94f00          CMP      r9,#0x8000
000036  d005              BEQ      |L9.68|
000038  f46f4000          MVN      r0,#0x8000
00003c  4448              ADD      r0,r0,r9
00003e  b960              CBNZ     r0,|L9.90|
000040  e006              B        |L9.80|
                  |L9.66|
;;;1257           case OS_OPT_POST_FLAG_SET:
;;;1258           case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
000042  bf00              NOP      
                  |L9.68|
;;;1259                p_grp->Flags |=  flags;                            /* Set   the flags specified in the group               */
000044  6a20              LDR      r0,[r4,#0x20]
000046  ea400008          ORR      r0,r0,r8
00004a  6220              STR      r0,[r4,#0x20]
;;;1260                break;
00004c  e015              B        |L9.122|
                  |L9.78|
;;;1261   
;;;1262           case OS_OPT_POST_FLAG_CLR:
;;;1263           case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
00004e  bf00              NOP      
                  |L9.80|
;;;1264                p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group               */
000050  6a20              LDR      r0,[r4,#0x20]
000052  ea200008          BIC      r0,r0,r8
000056  6220              STR      r0,[r4,#0x20]
;;;1265                break;
000058  e00f              B        |L9.122|
                  |L9.90|
;;;1266   
;;;1267           default:
;;;1268                CPU_CRITICAL_EXIT();                               /* INVALID option                                       */
00005a  bf00              NOP      
00005c  f7fffffe          BL       CPU_IntDisMeasStop
000060  bf00              NOP      
000062  9800              LDR      r0,[sp,#0]
000064  f7fffffe          BL       CPU_SR_Restore
000068  bf00              NOP      
00006a  bf00              NOP      
;;;1269               *p_err = OS_ERR_OPT_INVALID;
00006c  f6456025          MOV      r0,#0x5e25
000070  8038              STRH     r0,[r7,#0]
;;;1270                return (0u);
000072  2000              MOVS     r0,#0
                  |L9.116|
;;;1271       }
;;;1272   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1273       p_grp->TS   = ts;
;;;1274   #endif
;;;1275       p_pend_list = &p_grp->PendList;
;;;1276       if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on event flag group?                */
;;;1277           CPU_CRITICAL_EXIT();                                    /* No                                                   */
;;;1278          *p_err = OS_ERR_NONE;
;;;1279           return (p_grp->Flags);
;;;1280       }
;;;1281   
;;;1282       OS_CRITICAL_ENTER_CPU_EXIT();
;;;1283       p_pend_data = p_pend_list->HeadPtr;
;;;1284       p_tcb       = p_pend_data->TCBPtr;
;;;1285       while (p_tcb != DEF_NULL) {                                 /* Go through all tasks waiting on event flag(s)        */
;;;1286           p_pend_data_next = p_pend_data->NextPtr;
;;;1287           mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
;;;1288           switch (mode) {
;;;1289               case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node       */
;;;1290                    flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
;;;1291                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1292                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
;;;1293                                       flags_rdy,
;;;1294                                       ts);
;;;1295                    }
;;;1296                    break;
;;;1297   
;;;1298               case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                  */
;;;1299                    flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
;;;1300                    if (flags_rdy != 0u) {
;;;1301                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
;;;1302                                       flags_rdy,
;;;1303                                       ts);
;;;1304                    }
;;;1305                    break;
;;;1306   
;;;1307   #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
;;;1308               case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node       */
;;;1309                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1310                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1311                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
;;;1312                                       flags_rdy,
;;;1313                                       ts);
;;;1314                    }
;;;1315                    break;
;;;1316   
;;;1317               case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                  */
;;;1318                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1319                    if (flags_rdy != 0u) {
;;;1320                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
;;;1321                                       flags_rdy,
;;;1322                                       ts);
;;;1323                    }
;;;1324                    break;
;;;1325   #endif
;;;1326               default:
;;;1327                    OS_CRITICAL_EXIT();
;;;1328                   *p_err = OS_ERR_FLAG_PEND_OPT;
;;;1329                    return (0u);
;;;1330           }
;;;1331           p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)         */
;;;1332           if (p_pend_data != DEF_NULL) {
;;;1333               p_tcb = p_pend_data->TCBPtr;
;;;1334           } else {
;;;1335               p_tcb = DEF_NULL;
;;;1336           }
;;;1337       }
;;;1338       OS_CRITICAL_EXIT_NO_SCHED();
;;;1339   
;;;1340       if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
;;;1341           OSSched();
;;;1342       }
;;;1343   
;;;1344       CPU_CRITICAL_ENTER();
;;;1345       flags_cur = p_grp->Flags;
;;;1346       CPU_CRITICAL_EXIT();
;;;1347      *p_err     = OS_ERR_NONE;
;;;1348       return (flags_cur);
;;;1349   }
000074  b005              ADD      sp,sp,#0x14
000076  e8bd8ff0          POP      {r4-r11,pc}
                  |L9.122|
00007a  bf00              NOP                            ;1260
00007c  f8c4a024          STR      r10,[r4,#0x24]        ;1273
000080  f1040008          ADD      r0,r4,#8              ;1275
000084  9001              STR      r0,[sp,#4]            ;1275
000086  9801              LDR      r0,[sp,#4]            ;1276
000088  6800              LDR      r0,[r0,#0]            ;1276
00008a  b960              CBNZ     r0,|L9.166|
00008c  bf00              NOP                            ;1277
00008e  f7fffffe          BL       CPU_IntDisMeasStop
000092  bf00              NOP                            ;1277
000094  9800              LDR      r0,[sp,#0]            ;1277
000096  f7fffffe          BL       CPU_SR_Restore
00009a  bf00              NOP                            ;1277
00009c  bf00              NOP                            ;1277
00009e  2000              MOVS     r0,#0                 ;1278
0000a0  8038              STRH     r0,[r7,#0]            ;1278
0000a2  6a20              LDR      r0,[r4,#0x20]         ;1279
0000a4  e7e6              B        |L9.116|
                  |L9.166|
0000a6  9801              LDR      r0,[sp,#4]            ;1283
0000a8  6806              LDR      r6,[r0,#0]            ;1283
0000aa  68b5              LDR      r5,[r6,#8]            ;1284
0000ac  e03a              B        |L9.292|
                  |L9.174|
0000ae  6870              LDR      r0,[r6,#4]            ;1286
0000b0  9002              STR      r0,[sp,#8]            ;1286
0000b2  f8950084          LDRB     r0,[r5,#0x84]         ;1287
0000b6  f000000f          AND      r0,r0,#0xf            ;1287
0000ba  9003              STR      r0,[sp,#0xc]          ;1287
0000bc  9803              LDR      r0,[sp,#0xc]          ;1288
0000be  2804              CMP      r0,#4                 ;1288
0000c0  d002              BEQ      |L9.200|
0000c2  2808              CMP      r0,#8                 ;1288
0000c4  d11a              BNE      |L9.252|
0000c6  e00c              B        |L9.226|
                  |L9.200|
0000c8  6a20              LDR      r0,[r4,#0x20]         ;1290
0000ca  6fe9              LDR      r1,[r5,#0x7c]         ;1290
0000cc  ea000b01          AND      r11,r0,r1             ;1290
0000d0  6fe8              LDR      r0,[r5,#0x7c]         ;1291
0000d2  4558              CMP      r0,r11                ;1291
0000d4  d104              BNE      |L9.224|
0000d6  4652              MOV      r2,r10                ;1292
0000d8  4659              MOV      r1,r11                ;1292
0000da  4628              MOV      r0,r5                 ;1292
0000dc  f7fffffe          BL       OS_FlagTaskRdy
                  |L9.224|
0000e0  e01a              B        |L9.280|
                  |L9.226|
0000e2  6a20              LDR      r0,[r4,#0x20]         ;1299
0000e4  6fe9              LDR      r1,[r5,#0x7c]         ;1299
0000e6  ea000b01          AND      r11,r0,r1             ;1299
0000ea  f1bb0f00          CMP      r11,#0                ;1300
0000ee  d004              BEQ      |L9.250|
0000f0  4652              MOV      r2,r10                ;1301
0000f2  4659              MOV      r1,r11                ;1301
0000f4  4628              MOV      r0,r5                 ;1301
0000f6  f7fffffe          BL       OS_FlagTaskRdy
                  |L9.250|
0000fa  e00d              B        |L9.280|
                  |L9.252|
0000fc  bf00              NOP                            ;1327
0000fe  f7fffffe          BL       CPU_IntDisMeasStop
000102  bf00              NOP                            ;1327
000104  9800              LDR      r0,[sp,#0]            ;1327
000106  f7fffffe          BL       CPU_SR_Restore
00010a  bf00              NOP                            ;1327
00010c  bf00              NOP                            ;1327
00010e  f64320ff          MOV      r0,#0x3aff            ;1328
000112  8038              STRH     r0,[r7,#0]            ;1328
000114  2000              MOVS     r0,#0                 ;1329
000116  e7ad              B        |L9.116|
                  |L9.280|
000118  bf00              NOP                            ;1296
00011a  9e02              LDR      r6,[sp,#8]            ;1331
00011c  b10e              CBZ      r6,|L9.290|
00011e  68b5              LDR      r5,[r6,#8]            ;1333
000120  e000              B        |L9.292|
                  |L9.290|
000122  2500              MOVS     r5,#0                 ;1335
                  |L9.292|
000124  2d00              CMP      r5,#0                 ;1285
000126  d1c2              BNE      |L9.174|
000128  bf00              NOP                            ;1338
00012a  f7fffffe          BL       CPU_IntDisMeasStop
00012e  bf00              NOP                            ;1338
000130  9800              LDR      r0,[sp,#0]            ;1338
000132  f7fffffe          BL       CPU_SR_Restore
000136  bf00              NOP                            ;1338
000138  bf00              NOP                            ;1338
00013a  f4094000          AND      r0,r9,#0x8000         ;1340
00013e  b908              CBNZ     r0,|L9.324|
000140  f7fffffe          BL       OSSched
                  |L9.324|
000144  bf00              NOP                            ;1344
000146  bf00              NOP                            ;1344
000148  f7fffffe          BL       CPU_SR_Save
00014c  9000              STR      r0,[sp,#0]            ;1344
00014e  bf00              NOP                            ;1344
000150  f7fffffe          BL       CPU_IntDisMeasStart
000154  bf00              NOP                            ;1344
000156  6a20              LDR      r0,[r4,#0x20]         ;1345
000158  9004              STR      r0,[sp,#0x10]         ;1345
00015a  bf00              NOP                            ;1346
00015c  f7fffffe          BL       CPU_IntDisMeasStop
000160  bf00              NOP                            ;1346
000162  9800              LDR      r0,[sp,#0]            ;1346
000164  f7fffffe          BL       CPU_SR_Restore
000168  bf00              NOP                            ;1346
00016a  bf00              NOP                            ;1346
00016c  2000              MOVS     r0,#0                 ;1347
00016e  8038              STRH     r0,[r7,#0]            ;1347
000170  9804              LDR      r0,[sp,#0x10]         ;1348
000172  e77f              B        |L9.116|
;;;1350   
                          ENDP


                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=1

                  OS_FlagTaskRdy PROC
;;;1371   
;;;1372   void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1373                          OS_FLAGS   flags_rdy,
;;;1374                          CPU_TS     ts)
;;;1375   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1376   #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;1377       (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
;;;1378   #endif
;;;1379   
;;;1380       p_tcb->FlagsRdy   = flags_rdy;
000008  3434              ADDS     r4,r4,#0x34
00000a  64e6              STR      r6,[r4,#0x4c]
;;;1381       p_tcb->PendStatus = OS_STATUS_PEND_OK;                      /* Clear pend status                                    */
00000c  2000              MOVS     r0,#0
00000e  7060              STRB     r0,[r4,#1]
;;;1382       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;                /* Indicate no longer pending                           */
000010  7020              STRB     r0,[r4,#0]
;;;1383   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1384       p_tcb->TS         = ts;
000012  6165              STR      r5,[r4,#0x14]
;;;1385   #endif
;;;1386       switch (p_tcb->TaskState) {
000014  78a0              LDRB     r0,[r4,#2]
000016  3c34              SUBS     r4,r4,#0x34
000018  2808              CMP      r0,#8
00001a  d219              BCS      |L10.80|
00001c  e8dff000          TBB      [pc,r0]
000020  191a0405          DCB      0x19,0x1a,0x04,0x05
000024  1c1b1314          DCB      0x1c,0x1b,0x13,0x14
;;;1387           case OS_TASK_STATE_PEND:
;;;1388           case OS_TASK_STATE_PEND_TIMEOUT:
000028  bf00              NOP      
;;;1389   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;1390                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
00002a  f8940036          LDRB     r0,[r4,#0x36]
00002e  2803              CMP      r0,#3
000030  d102              BNE      |L10.56|
;;;1391                    OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       OS_TickListRemove
                  |L10.56|
;;;1392                }
;;;1393   #endif
;;;1394                OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       OS_RdyListInsert
;;;1395                p_tcb->TaskState = OS_TASK_STATE_RDY;
00003e  2000              MOVS     r0,#0
000040  f8840036          STRB     r0,[r4,#0x36]
;;;1396                break;
000044  e009              B        |L10.90|
;;;1397   
;;;1398           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1399           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000046  bf00              NOP      
;;;1400                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
000048  2004              MOVS     r0,#4
00004a  f8840036          STRB     r0,[r4,#0x36]
;;;1401                break;
00004e  e004              B        |L10.90|
                  |L10.80|
;;;1402   
;;;1403           case OS_TASK_STATE_RDY:
000050  bf00              NOP      
;;;1404           case OS_TASK_STATE_DLY:
000052  bf00              NOP      
;;;1405           case OS_TASK_STATE_DLY_SUSPENDED:
000054  bf00              NOP      
;;;1406           case OS_TASK_STATE_SUSPENDED:
000056  bf00              NOP      
;;;1407           default:
;;;1408                break;
000058  bf00              NOP      
                  |L10.90|
00005a  bf00              NOP                            ;1396
;;;1409       }
;;;1410       OS_PendListRemove(p_tcb);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       OS_PendListRemove
;;;1411   }
000062  bd70              POP      {r4-r6,pc}
;;;1412   #endif
                          ENDP

